<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>hjson API documentation</title>
    <meta name="description" content="Hjson, the Human JSON. A configuration file format that caters to
humans and helps reduce the errors..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#hjson.dump">dump</a></li>
    <li class="mono"><a href="#hjson.dumpJSON">dumpJSON</a></li>
    <li class="mono"><a href="#hjson.dumps">dumps</a></li>
    <li class="mono"><a href="#hjson.dumpsJSON">dumpsJSON</a></li>
    <li class="mono"><a href="#hjson.load">load</a></li>
    <li class="mono"><a href="#hjson.loads">loads</a></li>
    <li class="mono"><a href="#hjson.simple_first">simple_first</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#hjson.HjsonDecodeError">HjsonDecodeError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#hjson.HjsonDecodeError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#hjson.HjsonDecoder">HjsonDecoder</a></span>
        
          
  <ul>
    <li class="mono"><a href="#hjson.HjsonDecoder.__init__">__init__</a></li>
    <li class="mono"><a href="#hjson.HjsonDecoder.decode">decode</a></li>
    <li class="mono"><a href="#hjson.HjsonDecoder.raw_decode">raw_decode</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#hjson.HjsonEncoder">HjsonEncoder</a></span>
        
          
  <ul>
    <li class="mono"><a href="#hjson.HjsonEncoder.__init__">__init__</a></li>
    <li class="mono"><a href="#hjson.HjsonEncoder.default">default</a></li>
    <li class="mono"><a href="#hjson.HjsonEncoder.encode">encode</a></li>
    <li class="mono"><a href="#hjson.HjsonEncoder.iterencode">iterencode</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#hjson.JSONEncoder">JSONEncoder</a></span>
        
          
  <ul>
    <li class="mono"><a href="#hjson.JSONEncoder.__init__">__init__</a></li>
    <li class="mono"><a href="#hjson.JSONEncoder.default">default</a></li>
    <li class="mono"><a href="#hjson.JSONEncoder.encode">encode</a></li>
    <li class="mono"><a href="#hjson.JSONEncoder.iterencode">iterencode</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#hjson.OrderedDict">OrderedDict</a></span>
        
          
  <ul>
    <li class="mono"><a href="#hjson.OrderedDict.__init__">__init__</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.clear">clear</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.copy">copy</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.fromkeys">fromkeys</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.items">items</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.iteritems">iteritems</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.iterkeys">iterkeys</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.itervalues">itervalues</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.keys">keys</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.pop">pop</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.popitem">popitem</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.setdefault">setdefault</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.update">update</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.values">values</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.viewitems">viewitems</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.viewkeys">viewkeys</a></li>
    <li class="mono"><a href="#hjson.OrderedDict.viewvalues">viewvalues</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">hjson</span> module</h1>
  <p>Hjson, the Human JSON. A configuration file format that caters to
humans and helps reduce the errors they make.</p>
<p>For details and syntax see <a href="http://hjson.org">http://hjson.org</a>.</p>
<p>Decoding Hjson::</p>
<pre><code>&gt;&gt;&gt; import hjson
&gt;&gt;&gt; text = "{\n  foo: a\n  bar: 1\n}"
&gt;&gt;&gt; hjson.loads(text)
OrderedDict([('foo', 'a'), ('bar', 1)])
</code></pre>
<p>Encoding Python object hierarchies::</p>
<pre><code>&gt;&gt;&gt; import hjson
&gt;&gt;&gt; # hjson.dumps({'foo': 'text', 'bar': (1, 2)})
&gt;&gt;&gt; hjson.dumps(OrderedDict([('foo', 'text'), ('bar', (1, 2))]))
'{\n  foo: text\n  bar:\n  [\n    1\n    2\n  ]\n}'
</code></pre>
<p>Encoding as JSON::</p>
<pre><code>Note that this is probably not as performant as the simplejson version.

&gt;&gt;&gt; import hjson
&gt;&gt;&gt; hjson.dumpsJSON(['foo', {'bar': ('baz', None, 1.0, 2)}])
'["foo", {"bar": ["baz", null, 1.0, 2]}]'
</code></pre>
<p>Using hjson.tool from the shell to validate and pretty-print::</p>
<pre><code>$ echo '{"json":"obj"}' | python -m hjson.tool
{
  json: obj
}

Other formats are -c for compact or -j for formatted JSON.
</code></pre>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson', this);">Show source &equiv;</a></p>
  <div id="source-hjson" class="source">
    <pre><code>r"""Hjson, the Human JSON. A configuration file format that caters to
humans and helps reduce the errors they make.

For details and syntax see <http://hjson.org>.

Decoding Hjson::

    >>> import hjson
    >>> text = "{\n  foo: a\n  bar: 1\n}"
    >>> hjson.loads(text)
    OrderedDict([('foo', 'a'), ('bar', 1)])

Encoding Python object hierarchies::

    >>> import hjson
    >>> # hjson.dumps({'foo': 'text', 'bar': (1, 2)})
    >>> hjson.dumps(OrderedDict([('foo', 'text'), ('bar', (1, 2))]))
    '{\n  foo: text\n  bar:\n  [\n    1\n    2\n  ]\n}'

Encoding as JSON::

    Note that this is probably not as performant as the simplejson version.

    >>> import hjson
    >>> hjson.dumpsJSON(['foo', {'bar': ('baz', None, 1.0, 2)}])
    '["foo", {"bar": ["baz", null, 1.0, 2]}]'

Using hjson.tool from the shell to validate and pretty-print::

    $ echo '{"json":"obj"}' | python -m hjson.tool
    {
      json: obj
    }

    Other formats are -c for compact or -j for formatted JSON.

"""
from __future__ import absolute_import
__version__ = '2.0.0'
__all__ = [
    'dump', 'dumps', 'load', 'loads',
    'dumpJSON', 'dumpsJSON',
    'HjsonDecoder', 'HjsonDecodeError', 'HjsonEncoder', 'JSONEncoder',
    'OrderedDict', 'simple_first',
]

# based on simplejson by
# __author__ = 'Bob Ippolito <bob@redivi.com>'
__author__ = 'Christian Zangl <coralllama@gmail.com>'

from decimal import Decimal

from .scanner import HjsonDecodeError
from .decoder import HjsonDecoder
from .encoderH import HjsonEncoder
from .encoder import JSONEncoder
def _import_OrderedDict():
    import collections
    try:
        return collections.OrderedDict
    except AttributeError:
        from . import ordered_dict
        return ordered_dict.OrderedDict
OrderedDict = _import_OrderedDict()


_default_decoder = HjsonDecoder(encoding=None, object_hook=None,
                               object_pairs_hook=OrderedDict)


def load(fp, encoding=None, cls=None, object_hook=None, parse_float=None,
        parse_int=None, object_pairs_hook=OrderedDict,
        use_decimal=False, namedtuple_as_object=True, tuple_as_array=True,
        **kw):
    """Deserialize ``fp`` (a ``.read()``-supporting file-like object containing
    a JSON document) to a Python object.

    *encoding* determines the encoding used to interpret any
    :class:`str` objects decoded by this instance (``'utf-8'`` by
    default).  It has no effect when decoding :class:`unicode` objects.

    Note that currently only encodings that are a superset of ASCII work,
    strings of other encodings should be passed in as :class:`unicode`.

    *object_hook*, if specified, will be called with the result of every
    JSON object decoded and its return value will be used in place of the
    given :class:`dict`.  This can be used to provide custom
    deserializations (e.g. to support JSON-RPC class hinting).

    *object_pairs_hook* is an optional function that will be called with
    the result of any object literal decode with an ordered list of pairs.
    The return value of *object_pairs_hook* will be used instead of the
    :class:`dict`.  This feature can be used to implement custom decoders
    that rely on the order that the key and value pairs are decoded (for
    example, :func:`collections.OrderedDict` will remember the order of
    insertion). If *object_hook* is also defined, the *object_pairs_hook*
    takes priority.

    *parse_float*, if specified, will be called with the string of every
    JSON float to be decoded.  By default, this is equivalent to
    ``float(num_str)``. This can be used to use another datatype or parser
    for JSON floats (e.g. :class:`decimal.Decimal`).

    *parse_int*, if specified, will be called with the string of every
    JSON int to be decoded.  By default, this is equivalent to
    ``int(num_str)``.  This can be used to use another datatype or parser
    for JSON integers (e.g. :class:`float`).

    If *use_decimal* is true (default: ``False``) then it implies
    parse_float=decimal.Decimal for parity with ``dump``.

    To use a custom ``HjsonDecoder`` subclass, specify it with the ``cls``
    kwarg. NOTE: You should use *object_hook* or *object_pairs_hook* instead
    of subclassing whenever possible.

    """
    return loads(fp.read(),
        encoding=encoding, cls=cls, object_hook=object_hook,
        parse_float=parse_float, parse_int=parse_int,
        object_pairs_hook=object_pairs_hook,
        use_decimal=use_decimal, **kw)


def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None,
        parse_int=None, object_pairs_hook=None,
        use_decimal=False, **kw):
    """Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON
    document) to a Python object.

    *encoding* determines the encoding used to interpret any
    :class:`str` objects decoded by this instance (``'utf-8'`` by
    default).  It has no effect when decoding :class:`unicode` objects.

    Note that currently only encodings that are a superset of ASCII work,
    strings of other encodings should be passed in as :class:`unicode`.

    *object_hook*, if specified, will be called with the result of every
    JSON object decoded and its return value will be used in place of the
    given :class:`dict`.  This can be used to provide custom
    deserializations (e.g. to support JSON-RPC class hinting).

    *object_pairs_hook* is an optional function that will be called with
    the result of any object literal decode with an ordered list of pairs.
    The return value of *object_pairs_hook* will be used instead of the
    :class:`dict`.  This feature can be used to implement custom decoders
    that rely on the order that the key and value pairs are decoded (for
    example, :func:`collections.OrderedDict` will remember the order of
    insertion). If *object_hook* is also defined, the *object_pairs_hook*
    takes priority.

    *parse_float*, if specified, will be called with the string of every
    JSON float to be decoded.  By default, this is equivalent to
    ``float(num_str)``. This can be used to use another datatype or parser
    for JSON floats (e.g. :class:`decimal.Decimal`).

    *parse_int*, if specified, will be called with the string of every
    JSON int to be decoded.  By default, this is equivalent to
    ``int(num_str)``.  This can be used to use another datatype or parser
    for JSON integers (e.g. :class:`float`).

    If *use_decimal* is true (default: ``False``) then it implies
    parse_float=decimal.Decimal for parity with ``dump``.

    To use a custom ``HjsonDecoder`` subclass, specify it with the ``cls``
    kwarg. NOTE: You should use *object_hook* or *object_pairs_hook* instead
    of subclassing whenever possible.

    """
    if (cls is None and encoding is None and object_hook is None and
            parse_int is None and parse_float is None and
            object_pairs_hook is None
            and not use_decimal and not kw):
        return _default_decoder.decode(s)
    if cls is None:
        cls = HjsonDecoder
    if object_hook is not None:
        kw['object_hook'] = object_hook
    if object_pairs_hook is not None:
        kw['object_pairs_hook'] = object_pairs_hook
    if parse_float is not None:
        kw['parse_float'] = parse_float
    if parse_int is not None:
        kw['parse_int'] = parse_int
    if use_decimal:
        if parse_float is not None:
            raise TypeError("use_decimal=True implies parse_float=Decimal")
        kw['parse_float'] = Decimal
    return cls(encoding=encoding, **kw).decode(s)


_default_hjson_encoder = HjsonEncoder(
    skipkeys=False,
    ensure_ascii=True,
    check_circular=True,
    indent=None,
    encoding='utf-8',
    default=None,
    use_decimal=True,
    namedtuple_as_object=True,
    tuple_as_array=True,
    bigint_as_string=False,
    item_sort_key=None,
    for_json=False,
    int_as_string_bitcount=None,
)

def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True,
         cls=None, indent=None,
         encoding='utf-8', default=None, use_decimal=True,
         namedtuple_as_object=True, tuple_as_array=True,
         bigint_as_string=False, sort_keys=False, item_sort_key=None,
         for_json=False, int_as_string_bitcount=None, **kw):
    """Serialize ``obj`` as a JSON formatted stream to ``fp`` (a
    ``.write()``-supporting file-like object).

    If *skipkeys* is true then ``dict`` keys that are not basic types
    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)
    will be skipped instead of raising a ``TypeError``.

    If *ensure_ascii* is false, then the some chunks written to ``fp``
    may be ``unicode`` instances, subject to normal Python ``str`` to
    ``unicode`` coercion rules. Unless ``fp.write()`` explicitly
    understands ``unicode`` (as in ``codecs.getwriter()``) this is likely
    to cause an error.

    If *check_circular* is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``OverflowError`` (or worse).

    If *indent* is a string, then JSON array elements and object members
    will be pretty-printed with a newline followed by that string repeated
    for each level of nesting. ``None`` (the default) selects the most compact
    representation without any newlines. For backwards compatibility with
    versions of hjson earlier than 2.1.0, an integer is also accepted
    and is converted to a string with that many spaces.

    *encoding* is the character encoding for str instances, default is UTF-8.

    *default(obj)* is a function that should return a serializable version
    of obj or raise ``TypeError``. The default simply raises ``TypeError``.

    If *use_decimal* is true (default: ``True``) then decimal.Decimal
    will be natively serialized to JSON with full precision.

    If *namedtuple_as_object* is true (default: ``True``),
    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded
    as JSON objects.

    If *tuple_as_array* is true (default: ``True``),
    :class:`tuple` (and subclasses) will be encoded as JSON arrays.

    If *bigint_as_string* is true (default: ``False``), ints 2**53 and higher
    or lower than -2**53 will be encoded as strings. This is to avoid the
    rounding that happens in Javascript otherwise. Note that this is still a
    lossy operation that will not round-trip correctly and should be used
    sparingly.

    If *int_as_string_bitcount* is a positive number (n), then int of size
    greater than or equal to 2**n or lower than or equal to -2**n will be
    encoded as strings.

    If specified, *item_sort_key* is a callable used to sort the items in
    each dictionary. This is useful if you want to sort items other than
    in alphabetical order by key. This option takes precedence over
    *sort_keys*.

    If *sort_keys* is true (default: ``False``), the output of dictionaries
    will be sorted by item.

    If *for_json* is true (default: ``False``), objects with a ``for_json()``
    method will use the return value of that method for encoding as JSON
    instead of the object.

    To use a custom ``HjsonEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg. NOTE: You should use *default* or *for_json* instead
    of subclassing whenever possible.

    """
    # cached encoder
    if (not skipkeys and ensure_ascii and
        check_circular and
        cls is None and indent is None and
        encoding == 'utf-8' and default is None and use_decimal
        and namedtuple_as_object and tuple_as_array
        and not bigint_as_string and not sort_keys
        and not item_sort_key and not for_json
        and int_as_string_bitcount is None
        and not kw
    ):
        iterable = _default_hjson_encoder.iterencode(obj)
    else:
        if cls is None:
            cls = HjsonEncoder
        iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,
            check_circular=check_circular, indent=indent,
            encoding=encoding,
            default=default, use_decimal=use_decimal,
            namedtuple_as_object=namedtuple_as_object,
            tuple_as_array=tuple_as_array,
            bigint_as_string=bigint_as_string,
            sort_keys=sort_keys,
            item_sort_key=item_sort_key,
            for_json=for_json,
            int_as_string_bitcount=int_as_string_bitcount,
            **kw).iterencode(obj)
    # could accelerate with writelines in some versions of Python, at
    # a debuggability cost
    for chunk in iterable:
        fp.write(chunk)


def dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True,
          cls=None, indent=None,
          encoding='utf-8', default=None, use_decimal=True,
          namedtuple_as_object=True, tuple_as_array=True,
          bigint_as_string=False, sort_keys=False, item_sort_key=None,
          for_json=False, int_as_string_bitcount=None, **kw):
    """Serialize ``obj`` to a JSON formatted ``str``.

    If ``skipkeys`` is false then ``dict`` keys that are not basic types
    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)
    will be skipped instead of raising a ``TypeError``.

    If ``ensure_ascii`` is false, then the return value will be a
    ``unicode`` instance subject to normal Python ``str`` to ``unicode``
    coercion rules instead of being escaped to an ASCII ``str``.

    If ``check_circular`` is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``OverflowError`` (or worse).

    If ``indent`` is a string, then JSON array elements and object members
    will be pretty-printed with a newline followed by that string repeated
    for each level of nesting. ``None`` (the default) selects the most compact
    representation without any newlines. For backwards compatibility with
    versions of hjson earlier than 2.1.0, an integer is also accepted
    and is converted to a string with that many spaces.

    ``encoding`` is the character encoding for str instances, default is UTF-8.

    ``default(obj)`` is a function that should return a serializable version
    of obj or raise TypeError. The default simply raises TypeError.

    If *use_decimal* is true (default: ``True``) then decimal.Decimal
    will be natively serialized to JSON with full precision.

    If *namedtuple_as_object* is true (default: ``True``),
    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded
    as JSON objects.

    If *tuple_as_array* is true (default: ``True``),
    :class:`tuple` (and subclasses) will be encoded as JSON arrays.

    If *bigint_as_string* is true (not the default), ints 2**53 and higher
    or lower than -2**53 will be encoded as strings. This is to avoid the
    rounding that happens in Javascript otherwise.

    If *int_as_string_bitcount* is a positive number (n), then int of size
    greater than or equal to 2**n or lower than or equal to -2**n will be
    encoded as strings.

    If specified, *item_sort_key* is a callable used to sort the items in
    each dictionary. This is useful if you want to sort items other than
    in alphabetical order by key. This option takes precendence over
    *sort_keys*.

    If *sort_keys* is true (default: ``False``), the output of dictionaries
    will be sorted by item.

    If *for_json* is true (default: ``False``), objects with a ``for_json()``
    method will use the return value of that method for encoding as JSON
    instead of the object.

    To use a custom ``HjsonEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg. NOTE: You should use *default* instead of subclassing
    whenever possible.

    """
    # cached encoder
    if (
        not skipkeys and ensure_ascii and
        check_circular and
        cls is None and indent is None and
        encoding == 'utf-8' and default is None and use_decimal
        and namedtuple_as_object and tuple_as_array
        and not bigint_as_string and not sort_keys
        and not item_sort_key and not for_json
        and int_as_string_bitcount is None
        and not kw
    ):
        return _default_hjson_encoder.encode(obj)
    if cls is None:
        cls = HjsonEncoder
    return cls(
        skipkeys=skipkeys, ensure_ascii=ensure_ascii,
        check_circular=check_circular, indent=indent,
        encoding=encoding, default=default,
        use_decimal=use_decimal,
        namedtuple_as_object=namedtuple_as_object,
        tuple_as_array=tuple_as_array,
        bigint_as_string=bigint_as_string,
        sort_keys=sort_keys,
        item_sort_key=item_sort_key,
        for_json=for_json,
        int_as_string_bitcount=int_as_string_bitcount,
        **kw).encode(obj)



_default_json_encoder = JSONEncoder(
    skipkeys=False,
    ensure_ascii=True,
    check_circular=True,
    indent=None,
    separators=None,
    encoding='utf-8',
    default=None,
    use_decimal=True,
    namedtuple_as_object=True,
    tuple_as_array=True,
    bigint_as_string=False,
    item_sort_key=None,
    for_json=False,
    int_as_string_bitcount=None,
)

def dumpJSON(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True,
         cls=None, indent=None, separators=None,
         encoding='utf-8', default=None, use_decimal=True,
         namedtuple_as_object=True, tuple_as_array=True,
         bigint_as_string=False, sort_keys=False, item_sort_key=None,
         for_json=False, int_as_string_bitcount=None, **kw):
    """Serialize ``obj`` as a JSON formatted stream to ``fp`` (a
    ``.write()``-supporting file-like object).

    If *skipkeys* is true then ``dict`` keys that are not basic types
    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)
    will be skipped instead of raising a ``TypeError``.

    If *ensure_ascii* is false, then the some chunks written to ``fp``
    may be ``unicode`` instances, subject to normal Python ``str`` to
    ``unicode`` coercion rules. Unless ``fp.write()`` explicitly
    understands ``unicode`` (as in ``codecs.getwriter()``) this is likely
    to cause an error.

    If *check_circular* is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``OverflowError`` (or worse).

    If *indent* is a string, then JSON array elements and object members
    will be pretty-printed with a newline followed by that string repeated
    for each level of nesting. ``None`` (the default) selects the most compact
    representation without any newlines. An integer is also accepted
    and is converted to a string with that many spaces.

    If specified, *separators* should be an
    ``(item_separator, key_separator)`` tuple.  The default is ``(', ', ': ')``
    if *indent* is ``None`` and ``(',', ': ')`` otherwise.  To get the most
    compact JSON representation, you should specify ``(',', ':')`` to eliminate
    whitespace.

    *encoding* is the character encoding for str instances, default is UTF-8.

    *default(obj)* is a function that should return a serializable version
    of obj or raise ``TypeError``. The default simply raises ``TypeError``.

    If *use_decimal* is true (default: ``True``) then decimal.Decimal
    will be natively serialized to JSON with full precision.

    If *namedtuple_as_object* is true (default: ``True``),
    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded
    as JSON objects.

    If *tuple_as_array* is true (default: ``True``),
    :class:`tuple` (and subclasses) will be encoded as JSON arrays.

    If *bigint_as_string* is true (default: ``False``), ints 2**53 and higher
    or lower than -2**53 will be encoded as strings. This is to avoid the
    rounding that happens in Javascript otherwise. Note that this is still a
    lossy operation that will not round-trip correctly and should be used
    sparingly.

    If *int_as_string_bitcount* is a positive number (n), then int of size
    greater than or equal to 2**n or lower than or equal to -2**n will be
    encoded as strings.

    If specified, *item_sort_key* is a callable used to sort the items in
    each dictionary. This is useful if you want to sort items other than
    in alphabetical order by key. This option takes precedence over
    *sort_keys*.

    If *sort_keys* is true (default: ``False``), the output of dictionaries
    will be sorted by item.

    If *for_json* is true (default: ``False``), objects with a ``for_json()``
    method will use the return value of that method for encoding as JSON
    instead of the object.

    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg. NOTE: You should use *default* or *for_json* instead
    of subclassing whenever possible.

    """
    # cached encoder
    if (not skipkeys and ensure_ascii and
        check_circular and
        cls is None and indent is None and separators is None and
        encoding == 'utf-8' and default is None and use_decimal
        and namedtuple_as_object and tuple_as_array
        and not bigint_as_string and not sort_keys
        and not item_sort_key and not for_json
        and int_as_string_bitcount is None
        and not kw
    ):
        iterable = _default_json_encoder.iterencode(obj)
    else:
        if cls is None:
            cls = JSONEncoder
        iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,
            check_circular=check_circular, indent=indent,
            separators=separators, encoding=encoding,
            default=default, use_decimal=use_decimal,
            namedtuple_as_object=namedtuple_as_object,
            tuple_as_array=tuple_as_array,
            bigint_as_string=bigint_as_string,
            sort_keys=sort_keys,
            item_sort_key=item_sort_key,
            for_json=for_json,
            int_as_string_bitcount=int_as_string_bitcount,
            **kw).iterencode(obj)
    # could accelerate with writelines in some versions of Python, at
    # a debuggability cost
    for chunk in iterable:
        fp.write(chunk)


def dumpsJSON(obj, skipkeys=False, ensure_ascii=True, check_circular=True,
          cls=None, indent=None, separators=None,
          encoding='utf-8', default=None, use_decimal=True,
          namedtuple_as_object=True, tuple_as_array=True,
          bigint_as_string=False, sort_keys=False, item_sort_key=None,
          for_json=False, int_as_string_bitcount=None, **kw):
    """Serialize ``obj`` to a JSON formatted ``str``.

    If ``skipkeys`` is false then ``dict`` keys that are not basic types
    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)
    will be skipped instead of raising a ``TypeError``.

    If ``ensure_ascii`` is false, then the return value will be a
    ``unicode`` instance subject to normal Python ``str`` to ``unicode``
    coercion rules instead of being escaped to an ASCII ``str``.

    If ``check_circular`` is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``OverflowError`` (or worse).

    If ``indent`` is a string, then JSON array elements and object members
    will be pretty-printed with a newline followed by that string repeated
    for each level of nesting. ``None`` (the default) selects the most compact
    representation without any newlines. An integer is also accepted
    and is converted to a string with that many spaces.

    If specified, ``separators`` should be an
    ``(item_separator, key_separator)`` tuple.  The default is ``(', ', ': ')``
    if *indent* is ``None`` and ``(',', ': ')`` otherwise.  To get the most
    compact JSON representation, you should specify ``(',', ':')`` to eliminate
    whitespace.

    ``encoding`` is the character encoding for str instances, default is UTF-8.

    ``default(obj)`` is a function that should return a serializable version
    of obj or raise TypeError. The default simply raises TypeError.

    If *use_decimal* is true (default: ``True``) then decimal.Decimal
    will be natively serialized to JSON with full precision.

    If *namedtuple_as_object* is true (default: ``True``),
    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded
    as JSON objects.

    If *tuple_as_array* is true (default: ``True``),
    :class:`tuple` (and subclasses) will be encoded as JSON arrays.

    If *bigint_as_string* is true (not the default), ints 2**53 and higher
    or lower than -2**53 will be encoded as strings. This is to avoid the
    rounding that happens in Javascript otherwise.

    If *int_as_string_bitcount* is a positive number (n), then int of size
    greater than or equal to 2**n or lower than or equal to -2**n will be
    encoded as strings.

    If specified, *item_sort_key* is a callable used to sort the items in
    each dictionary. This is useful if you want to sort items other than
    in alphabetical order by key. This option takes precendence over
    *sort_keys*.

    If *sort_keys* is true (default: ``False``), the output of dictionaries
    will be sorted by item.

    If *for_json* is true (default: ``False``), objects with a ``for_json()``
    method will use the return value of that method for encoding as JSON
    instead of the object.

    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg. NOTE: You should use *default* instead of subclassing
    whenever possible.

    """
    # cached encoder
    if (
        not skipkeys and ensure_ascii and
        check_circular and
        cls is None and indent is None and separators is None and
        encoding == 'utf-8' and default is None and use_decimal
        and namedtuple_as_object and tuple_as_array
        and not bigint_as_string and not sort_keys
        and not item_sort_key and not for_json
        and int_as_string_bitcount is None
        and not kw
    ):
        return _default_json_encoder.encode(obj)
    if cls is None:
        cls = JSONEncoder
    return cls(
        skipkeys=skipkeys, ensure_ascii=ensure_ascii,
        check_circular=check_circular, indent=indent,
        separators=separators, encoding=encoding, default=default,
        use_decimal=use_decimal,
        namedtuple_as_object=namedtuple_as_object,
        tuple_as_array=tuple_as_array,
        bigint_as_string=bigint_as_string,
        sort_keys=sort_keys,
        item_sort_key=item_sort_key,
        for_json=for_json,
        int_as_string_bitcount=int_as_string_bitcount,
        **kw).encode(obj)



def simple_first(kv):
    """Helper function to pass to item_sort_key to sort simple
    elements to the top, then container elements.
    """
    return (isinstance(kv[1], (list, dict, tuple)), kv[0])
</code></pre>
  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="hjson.dump">
    <p>def <span class="ident">dump</span>(</p><p>obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, cls=None, indent=None, encoding=&#39;utf-8&#39;, default=None, use_decimal=True, namedtuple_as_object=True, tuple_as_array=True, bigint_as_string=False, sort_keys=False, item_sort_key=None, for_json=False, int_as_string_bitcount=None, **kw)</p>
    </div>
    

    
  
    <div class="desc"><p>Serialize <code>obj</code> as a JSON formatted stream to <code>fp</code> (a
<code>.write()</code>-supporting file-like object).</p>
<p>If <em>skipkeys</em> is true then <code>dict</code> keys that are not basic types
(<code>str</code>, <code>unicode</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>bool</code>, <code>None</code>)
will be skipped instead of raising a <code>TypeError</code>.</p>
<p>If <em>ensure_ascii</em> is false, then the some chunks written to <code>fp</code>
may be <code>unicode</code> instances, subject to normal Python <code>str</code> to
<code>unicode</code> coercion rules. Unless <code>fp.write()</code> explicitly
understands <code>unicode</code> (as in <code>codecs.getwriter()</code>) this is likely
to cause an error.</p>
<p>If <em>check_circular</em> is false, then the circular reference check
for container types will be skipped and a circular reference will
result in an <code>OverflowError</code> (or worse).</p>
<p>If <em>indent</em> is a string, then JSON array elements and object members
will be pretty-printed with a newline followed by that string repeated
for each level of nesting. <code>None</code> (the default) selects the most compact
representation without any newlines. For backwards compatibility with
versions of hjson earlier than 2.1.0, an integer is also accepted
and is converted to a string with that many spaces.</p>
<p><em>encoding</em> is the character encoding for str instances, default is UTF-8.</p>
<p><em>default(obj)</em> is a function that should return a serializable version
of obj or raise <code>TypeError</code>. The default simply raises <code>TypeError</code>.</p>
<p>If <em>use_decimal</em> is true (default: <code>True</code>) then decimal.Decimal
will be natively serialized to JSON with full precision.</p>
<p>If <em>namedtuple_as_object</em> is true (default: <code>True</code>),
:class:<code>tuple</code> subclasses with <code>_asdict()</code> methods will be encoded
as JSON objects.</p>
<p>If <em>tuple_as_array</em> is true (default: <code>True</code>),
:class:<code>tuple</code> (and subclasses) will be encoded as JSON arrays.</p>
<p>If <em>bigint_as_string</em> is true (default: <code>False</code>), ints 2<strong>53 and higher
or lower than -2</strong>53 will be encoded as strings. This is to avoid the
rounding that happens in Javascript otherwise. Note that this is still a
lossy operation that will not round-trip correctly and should be used
sparingly.</p>
<p>If <em>int_as_string_bitcount</em> is a positive number (n), then int of size
greater than or equal to 2<strong>n or lower than or equal to -2</strong>n will be
encoded as strings.</p>
<p>If specified, <em>item_sort_key</em> is a callable used to sort the items in
each dictionary. This is useful if you want to sort items other than
in alphabetical order by key. This option takes precedence over
<em>sort_keys</em>.</p>
<p>If <em>sort_keys</em> is true (default: <code>False</code>), the output of dictionaries
will be sorted by item.</p>
<p>If <em>for_json</em> is true (default: <code>False</code>), objects with a <code>for_json()</code>
method will use the return value of that method for encoding as JSON
instead of the object.</p>
<p>To use a custom <code>HjsonEncoder</code> subclass (e.g. one that overrides the
<code>.default()</code> method to serialize additional types), specify it with
the <code>cls</code> kwarg. NOTE: You should use <em>default</em> or <em>for_json</em> instead
of subclassing whenever possible.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.dump', this);">Show source &equiv;</a></p>
  <div id="source-hjson.dump" class="source">
    <pre><code>def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True,
         cls=None, indent=None,
         encoding='utf-8', default=None, use_decimal=True,
         namedtuple_as_object=True, tuple_as_array=True,
         bigint_as_string=False, sort_keys=False, item_sort_key=None,
         for_json=False, int_as_string_bitcount=None, **kw):
    """Serialize ``obj`` as a JSON formatted stream to ``fp`` (a
    ``.write()``-supporting file-like object).

    If *skipkeys* is true then ``dict`` keys that are not basic types
    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)
    will be skipped instead of raising a ``TypeError``.

    If *ensure_ascii* is false, then the some chunks written to ``fp``
    may be ``unicode`` instances, subject to normal Python ``str`` to
    ``unicode`` coercion rules. Unless ``fp.write()`` explicitly
    understands ``unicode`` (as in ``codecs.getwriter()``) this is likely
    to cause an error.

    If *check_circular* is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``OverflowError`` (or worse).

    If *indent* is a string, then JSON array elements and object members
    will be pretty-printed with a newline followed by that string repeated
    for each level of nesting. ``None`` (the default) selects the most compact
    representation without any newlines. For backwards compatibility with
    versions of hjson earlier than 2.1.0, an integer is also accepted
    and is converted to a string with that many spaces.

    *encoding* is the character encoding for str instances, default is UTF-8.

    *default(obj)* is a function that should return a serializable version
    of obj or raise ``TypeError``. The default simply raises ``TypeError``.

    If *use_decimal* is true (default: ``True``) then decimal.Decimal
    will be natively serialized to JSON with full precision.

    If *namedtuple_as_object* is true (default: ``True``),
    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded
    as JSON objects.

    If *tuple_as_array* is true (default: ``True``),
    :class:`tuple` (and subclasses) will be encoded as JSON arrays.

    If *bigint_as_string* is true (default: ``False``), ints 2**53 and higher
    or lower than -2**53 will be encoded as strings. This is to avoid the
    rounding that happens in Javascript otherwise. Note that this is still a
    lossy operation that will not round-trip correctly and should be used
    sparingly.

    If *int_as_string_bitcount* is a positive number (n), then int of size
    greater than or equal to 2**n or lower than or equal to -2**n will be
    encoded as strings.

    If specified, *item_sort_key* is a callable used to sort the items in
    each dictionary. This is useful if you want to sort items other than
    in alphabetical order by key. This option takes precedence over
    *sort_keys*.

    If *sort_keys* is true (default: ``False``), the output of dictionaries
    will be sorted by item.

    If *for_json* is true (default: ``False``), objects with a ``for_json()``
    method will use the return value of that method for encoding as JSON
    instead of the object.

    To use a custom ``HjsonEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg. NOTE: You should use *default* or *for_json* instead
    of subclassing whenever possible.

    """
    # cached encoder
    if (not skipkeys and ensure_ascii and
        check_circular and
        cls is None and indent is None and
        encoding == 'utf-8' and default is None and use_decimal
        and namedtuple_as_object and tuple_as_array
        and not bigint_as_string and not sort_keys
        and not item_sort_key and not for_json
        and int_as_string_bitcount is None
        and not kw
    ):
        iterable = _default_hjson_encoder.iterencode(obj)
    else:
        if cls is None:
            cls = HjsonEncoder
        iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,
            check_circular=check_circular, indent=indent,
            encoding=encoding,
            default=default, use_decimal=use_decimal,
            namedtuple_as_object=namedtuple_as_object,
            tuple_as_array=tuple_as_array,
            bigint_as_string=bigint_as_string,
            sort_keys=sort_keys,
            item_sort_key=item_sort_key,
            for_json=for_json,
            int_as_string_bitcount=int_as_string_bitcount,
            **kw).iterencode(obj)
    # could accelerate with writelines in some versions of Python, at
    # a debuggability cost
    for chunk in iterable:
        fp.write(chunk)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="hjson.dumpJSON">
    <p>def <span class="ident">dumpJSON</span>(</p><p>obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, cls=None, indent=None, separators=None, encoding=&#39;utf-8&#39;, default=None, use_decimal=True, namedtuple_as_object=True, tuple_as_array=True, bigint_as_string=False, sort_keys=False, item_sort_key=None, for_json=False, int_as_string_bitcount=None, **kw)</p>
    </div>
    

    
  
    <div class="desc"><p>Serialize <code>obj</code> as a JSON formatted stream to <code>fp</code> (a
<code>.write()</code>-supporting file-like object).</p>
<p>If <em>skipkeys</em> is true then <code>dict</code> keys that are not basic types
(<code>str</code>, <code>unicode</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>bool</code>, <code>None</code>)
will be skipped instead of raising a <code>TypeError</code>.</p>
<p>If <em>ensure_ascii</em> is false, then the some chunks written to <code>fp</code>
may be <code>unicode</code> instances, subject to normal Python <code>str</code> to
<code>unicode</code> coercion rules. Unless <code>fp.write()</code> explicitly
understands <code>unicode</code> (as in <code>codecs.getwriter()</code>) this is likely
to cause an error.</p>
<p>If <em>check_circular</em> is false, then the circular reference check
for container types will be skipped and a circular reference will
result in an <code>OverflowError</code> (or worse).</p>
<p>If <em>indent</em> is a string, then JSON array elements and object members
will be pretty-printed with a newline followed by that string repeated
for each level of nesting. <code>None</code> (the default) selects the most compact
representation without any newlines. An integer is also accepted
and is converted to a string with that many spaces.</p>
<p>If specified, <em>separators</em> should be an
<code>(item_separator, key_separator)</code> tuple.  The default is <code>(', ', ': ')</code>
if <em>indent</em> is <code>None</code> and <code>(',', ': ')</code> otherwise.  To get the most
compact JSON representation, you should specify <code>(',', ':')</code> to eliminate
whitespace.</p>
<p><em>encoding</em> is the character encoding for str instances, default is UTF-8.</p>
<p><em>default(obj)</em> is a function that should return a serializable version
of obj or raise <code>TypeError</code>. The default simply raises <code>TypeError</code>.</p>
<p>If <em>use_decimal</em> is true (default: <code>True</code>) then decimal.Decimal
will be natively serialized to JSON with full precision.</p>
<p>If <em>namedtuple_as_object</em> is true (default: <code>True</code>),
:class:<code>tuple</code> subclasses with <code>_asdict()</code> methods will be encoded
as JSON objects.</p>
<p>If <em>tuple_as_array</em> is true (default: <code>True</code>),
:class:<code>tuple</code> (and subclasses) will be encoded as JSON arrays.</p>
<p>If <em>bigint_as_string</em> is true (default: <code>False</code>), ints 2<strong>53 and higher
or lower than -2</strong>53 will be encoded as strings. This is to avoid the
rounding that happens in Javascript otherwise. Note that this is still a
lossy operation that will not round-trip correctly and should be used
sparingly.</p>
<p>If <em>int_as_string_bitcount</em> is a positive number (n), then int of size
greater than or equal to 2<strong>n or lower than or equal to -2</strong>n will be
encoded as strings.</p>
<p>If specified, <em>item_sort_key</em> is a callable used to sort the items in
each dictionary. This is useful if you want to sort items other than
in alphabetical order by key. This option takes precedence over
<em>sort_keys</em>.</p>
<p>If <em>sort_keys</em> is true (default: <code>False</code>), the output of dictionaries
will be sorted by item.</p>
<p>If <em>for_json</em> is true (default: <code>False</code>), objects with a <code>for_json()</code>
method will use the return value of that method for encoding as JSON
instead of the object.</p>
<p>To use a custom <code>JSONEncoder</code> subclass (e.g. one that overrides the
<code>.default()</code> method to serialize additional types), specify it with
the <code>cls</code> kwarg. NOTE: You should use <em>default</em> or <em>for_json</em> instead
of subclassing whenever possible.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.dumpJSON', this);">Show source &equiv;</a></p>
  <div id="source-hjson.dumpJSON" class="source">
    <pre><code>def dumpJSON(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True,
         cls=None, indent=None, separators=None,
         encoding='utf-8', default=None, use_decimal=True,
         namedtuple_as_object=True, tuple_as_array=True,
         bigint_as_string=False, sort_keys=False, item_sort_key=None,
         for_json=False, int_as_string_bitcount=None, **kw):
    """Serialize ``obj`` as a JSON formatted stream to ``fp`` (a
    ``.write()``-supporting file-like object).

    If *skipkeys* is true then ``dict`` keys that are not basic types
    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)
    will be skipped instead of raising a ``TypeError``.

    If *ensure_ascii* is false, then the some chunks written to ``fp``
    may be ``unicode`` instances, subject to normal Python ``str`` to
    ``unicode`` coercion rules. Unless ``fp.write()`` explicitly
    understands ``unicode`` (as in ``codecs.getwriter()``) this is likely
    to cause an error.

    If *check_circular* is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``OverflowError`` (or worse).

    If *indent* is a string, then JSON array elements and object members
    will be pretty-printed with a newline followed by that string repeated
    for each level of nesting. ``None`` (the default) selects the most compact
    representation without any newlines. An integer is also accepted
    and is converted to a string with that many spaces.

    If specified, *separators* should be an
    ``(item_separator, key_separator)`` tuple.  The default is ``(', ', ': ')``
    if *indent* is ``None`` and ``(',', ': ')`` otherwise.  To get the most
    compact JSON representation, you should specify ``(',', ':')`` to eliminate
    whitespace.

    *encoding* is the character encoding for str instances, default is UTF-8.

    *default(obj)* is a function that should return a serializable version
    of obj or raise ``TypeError``. The default simply raises ``TypeError``.

    If *use_decimal* is true (default: ``True``) then decimal.Decimal
    will be natively serialized to JSON with full precision.

    If *namedtuple_as_object* is true (default: ``True``),
    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded
    as JSON objects.

    If *tuple_as_array* is true (default: ``True``),
    :class:`tuple` (and subclasses) will be encoded as JSON arrays.

    If *bigint_as_string* is true (default: ``False``), ints 2**53 and higher
    or lower than -2**53 will be encoded as strings. This is to avoid the
    rounding that happens in Javascript otherwise. Note that this is still a
    lossy operation that will not round-trip correctly and should be used
    sparingly.

    If *int_as_string_bitcount* is a positive number (n), then int of size
    greater than or equal to 2**n or lower than or equal to -2**n will be
    encoded as strings.

    If specified, *item_sort_key* is a callable used to sort the items in
    each dictionary. This is useful if you want to sort items other than
    in alphabetical order by key. This option takes precedence over
    *sort_keys*.

    If *sort_keys* is true (default: ``False``), the output of dictionaries
    will be sorted by item.

    If *for_json* is true (default: ``False``), objects with a ``for_json()``
    method will use the return value of that method for encoding as JSON
    instead of the object.

    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg. NOTE: You should use *default* or *for_json* instead
    of subclassing whenever possible.

    """
    # cached encoder
    if (not skipkeys and ensure_ascii and
        check_circular and
        cls is None and indent is None and separators is None and
        encoding == 'utf-8' and default is None and use_decimal
        and namedtuple_as_object and tuple_as_array
        and not bigint_as_string and not sort_keys
        and not item_sort_key and not for_json
        and int_as_string_bitcount is None
        and not kw
    ):
        iterable = _default_json_encoder.iterencode(obj)
    else:
        if cls is None:
            cls = JSONEncoder
        iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,
            check_circular=check_circular, indent=indent,
            separators=separators, encoding=encoding,
            default=default, use_decimal=use_decimal,
            namedtuple_as_object=namedtuple_as_object,
            tuple_as_array=tuple_as_array,
            bigint_as_string=bigint_as_string,
            sort_keys=sort_keys,
            item_sort_key=item_sort_key,
            for_json=for_json,
            int_as_string_bitcount=int_as_string_bitcount,
            **kw).iterencode(obj)
    # could accelerate with writelines in some versions of Python, at
    # a debuggability cost
    for chunk in iterable:
        fp.write(chunk)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="hjson.dumps">
    <p>def <span class="ident">dumps</span>(</p><p>obj, skipkeys=False, ensure_ascii=True, check_circular=True, cls=None, indent=None, encoding=&#39;utf-8&#39;, default=None, use_decimal=True, namedtuple_as_object=True, tuple_as_array=True, bigint_as_string=False, sort_keys=False, item_sort_key=None, for_json=False, int_as_string_bitcount=None, **kw)</p>
    </div>
    

    
  
    <div class="desc"><p>Serialize <code>obj</code> to a JSON formatted <code>str</code>.</p>
<p>If <code>skipkeys</code> is false then <code>dict</code> keys that are not basic types
(<code>str</code>, <code>unicode</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>bool</code>, <code>None</code>)
will be skipped instead of raising a <code>TypeError</code>.</p>
<p>If <code>ensure_ascii</code> is false, then the return value will be a
<code>unicode</code> instance subject to normal Python <code>str</code> to <code>unicode</code>
coercion rules instead of being escaped to an ASCII <code>str</code>.</p>
<p>If <code>check_circular</code> is false, then the circular reference check
for container types will be skipped and a circular reference will
result in an <code>OverflowError</code> (or worse).</p>
<p>If <code>indent</code> is a string, then JSON array elements and object members
will be pretty-printed with a newline followed by that string repeated
for each level of nesting. <code>None</code> (the default) selects the most compact
representation without any newlines. For backwards compatibility with
versions of hjson earlier than 2.1.0, an integer is also accepted
and is converted to a string with that many spaces.</p>
<p><code>encoding</code> is the character encoding for str instances, default is UTF-8.</p>
<p><code>default(obj)</code> is a function that should return a serializable version
of obj or raise TypeError. The default simply raises TypeError.</p>
<p>If <em>use_decimal</em> is true (default: <code>True</code>) then decimal.Decimal
will be natively serialized to JSON with full precision.</p>
<p>If <em>namedtuple_as_object</em> is true (default: <code>True</code>),
:class:<code>tuple</code> subclasses with <code>_asdict()</code> methods will be encoded
as JSON objects.</p>
<p>If <em>tuple_as_array</em> is true (default: <code>True</code>),
:class:<code>tuple</code> (and subclasses) will be encoded as JSON arrays.</p>
<p>If <em>bigint_as_string</em> is true (not the default), ints 2<strong>53 and higher
or lower than -2</strong>53 will be encoded as strings. This is to avoid the
rounding that happens in Javascript otherwise.</p>
<p>If <em>int_as_string_bitcount</em> is a positive number (n), then int of size
greater than or equal to 2<strong>n or lower than or equal to -2</strong>n will be
encoded as strings.</p>
<p>If specified, <em>item_sort_key</em> is a callable used to sort the items in
each dictionary. This is useful if you want to sort items other than
in alphabetical order by key. This option takes precendence over
<em>sort_keys</em>.</p>
<p>If <em>sort_keys</em> is true (default: <code>False</code>), the output of dictionaries
will be sorted by item.</p>
<p>If <em>for_json</em> is true (default: <code>False</code>), objects with a <code>for_json()</code>
method will use the return value of that method for encoding as JSON
instead of the object.</p>
<p>To use a custom <code>HjsonEncoder</code> subclass (e.g. one that overrides the
<code>.default()</code> method to serialize additional types), specify it with
the <code>cls</code> kwarg. NOTE: You should use <em>default</em> instead of subclassing
whenever possible.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.dumps', this);">Show source &equiv;</a></p>
  <div id="source-hjson.dumps" class="source">
    <pre><code>def dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True,
          cls=None, indent=None,
          encoding='utf-8', default=None, use_decimal=True,
          namedtuple_as_object=True, tuple_as_array=True,
          bigint_as_string=False, sort_keys=False, item_sort_key=None,
          for_json=False, int_as_string_bitcount=None, **kw):
    """Serialize ``obj`` to a JSON formatted ``str``.

    If ``skipkeys`` is false then ``dict`` keys that are not basic types
    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)
    will be skipped instead of raising a ``TypeError``.

    If ``ensure_ascii`` is false, then the return value will be a
    ``unicode`` instance subject to normal Python ``str`` to ``unicode``
    coercion rules instead of being escaped to an ASCII ``str``.

    If ``check_circular`` is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``OverflowError`` (or worse).

    If ``indent`` is a string, then JSON array elements and object members
    will be pretty-printed with a newline followed by that string repeated
    for each level of nesting. ``None`` (the default) selects the most compact
    representation without any newlines. For backwards compatibility with
    versions of hjson earlier than 2.1.0, an integer is also accepted
    and is converted to a string with that many spaces.

    ``encoding`` is the character encoding for str instances, default is UTF-8.

    ``default(obj)`` is a function that should return a serializable version
    of obj or raise TypeError. The default simply raises TypeError.

    If *use_decimal* is true (default: ``True``) then decimal.Decimal
    will be natively serialized to JSON with full precision.

    If *namedtuple_as_object* is true (default: ``True``),
    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded
    as JSON objects.

    If *tuple_as_array* is true (default: ``True``),
    :class:`tuple` (and subclasses) will be encoded as JSON arrays.

    If *bigint_as_string* is true (not the default), ints 2**53 and higher
    or lower than -2**53 will be encoded as strings. This is to avoid the
    rounding that happens in Javascript otherwise.

    If *int_as_string_bitcount* is a positive number (n), then int of size
    greater than or equal to 2**n or lower than or equal to -2**n will be
    encoded as strings.

    If specified, *item_sort_key* is a callable used to sort the items in
    each dictionary. This is useful if you want to sort items other than
    in alphabetical order by key. This option takes precendence over
    *sort_keys*.

    If *sort_keys* is true (default: ``False``), the output of dictionaries
    will be sorted by item.

    If *for_json* is true (default: ``False``), objects with a ``for_json()``
    method will use the return value of that method for encoding as JSON
    instead of the object.

    To use a custom ``HjsonEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg. NOTE: You should use *default* instead of subclassing
    whenever possible.

    """
    # cached encoder
    if (
        not skipkeys and ensure_ascii and
        check_circular and
        cls is None and indent is None and
        encoding == 'utf-8' and default is None and use_decimal
        and namedtuple_as_object and tuple_as_array
        and not bigint_as_string and not sort_keys
        and not item_sort_key and not for_json
        and int_as_string_bitcount is None
        and not kw
    ):
        return _default_hjson_encoder.encode(obj)
    if cls is None:
        cls = HjsonEncoder
    return cls(
        skipkeys=skipkeys, ensure_ascii=ensure_ascii,
        check_circular=check_circular, indent=indent,
        encoding=encoding, default=default,
        use_decimal=use_decimal,
        namedtuple_as_object=namedtuple_as_object,
        tuple_as_array=tuple_as_array,
        bigint_as_string=bigint_as_string,
        sort_keys=sort_keys,
        item_sort_key=item_sort_key,
        for_json=for_json,
        int_as_string_bitcount=int_as_string_bitcount,
        **kw).encode(obj)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="hjson.dumpsJSON">
    <p>def <span class="ident">dumpsJSON</span>(</p><p>obj, skipkeys=False, ensure_ascii=True, check_circular=True, cls=None, indent=None, separators=None, encoding=&#39;utf-8&#39;, default=None, use_decimal=True, namedtuple_as_object=True, tuple_as_array=True, bigint_as_string=False, sort_keys=False, item_sort_key=None, for_json=False, int_as_string_bitcount=None, **kw)</p>
    </div>
    

    
  
    <div class="desc"><p>Serialize <code>obj</code> to a JSON formatted <code>str</code>.</p>
<p>If <code>skipkeys</code> is false then <code>dict</code> keys that are not basic types
(<code>str</code>, <code>unicode</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>bool</code>, <code>None</code>)
will be skipped instead of raising a <code>TypeError</code>.</p>
<p>If <code>ensure_ascii</code> is false, then the return value will be a
<code>unicode</code> instance subject to normal Python <code>str</code> to <code>unicode</code>
coercion rules instead of being escaped to an ASCII <code>str</code>.</p>
<p>If <code>check_circular</code> is false, then the circular reference check
for container types will be skipped and a circular reference will
result in an <code>OverflowError</code> (or worse).</p>
<p>If <code>indent</code> is a string, then JSON array elements and object members
will be pretty-printed with a newline followed by that string repeated
for each level of nesting. <code>None</code> (the default) selects the most compact
representation without any newlines. An integer is also accepted
and is converted to a string with that many spaces.</p>
<p>If specified, <code>separators</code> should be an
<code>(item_separator, key_separator)</code> tuple.  The default is <code>(', ', ': ')</code>
if <em>indent</em> is <code>None</code> and <code>(',', ': ')</code> otherwise.  To get the most
compact JSON representation, you should specify <code>(',', ':')</code> to eliminate
whitespace.</p>
<p><code>encoding</code> is the character encoding for str instances, default is UTF-8.</p>
<p><code>default(obj)</code> is a function that should return a serializable version
of obj or raise TypeError. The default simply raises TypeError.</p>
<p>If <em>use_decimal</em> is true (default: <code>True</code>) then decimal.Decimal
will be natively serialized to JSON with full precision.</p>
<p>If <em>namedtuple_as_object</em> is true (default: <code>True</code>),
:class:<code>tuple</code> subclasses with <code>_asdict()</code> methods will be encoded
as JSON objects.</p>
<p>If <em>tuple_as_array</em> is true (default: <code>True</code>),
:class:<code>tuple</code> (and subclasses) will be encoded as JSON arrays.</p>
<p>If <em>bigint_as_string</em> is true (not the default), ints 2<strong>53 and higher
or lower than -2</strong>53 will be encoded as strings. This is to avoid the
rounding that happens in Javascript otherwise.</p>
<p>If <em>int_as_string_bitcount</em> is a positive number (n), then int of size
greater than or equal to 2<strong>n or lower than or equal to -2</strong>n will be
encoded as strings.</p>
<p>If specified, <em>item_sort_key</em> is a callable used to sort the items in
each dictionary. This is useful if you want to sort items other than
in alphabetical order by key. This option takes precendence over
<em>sort_keys</em>.</p>
<p>If <em>sort_keys</em> is true (default: <code>False</code>), the output of dictionaries
will be sorted by item.</p>
<p>If <em>for_json</em> is true (default: <code>False</code>), objects with a <code>for_json()</code>
method will use the return value of that method for encoding as JSON
instead of the object.</p>
<p>To use a custom <code>JSONEncoder</code> subclass (e.g. one that overrides the
<code>.default()</code> method to serialize additional types), specify it with
the <code>cls</code> kwarg. NOTE: You should use <em>default</em> instead of subclassing
whenever possible.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.dumpsJSON', this);">Show source &equiv;</a></p>
  <div id="source-hjson.dumpsJSON" class="source">
    <pre><code>def dumpsJSON(obj, skipkeys=False, ensure_ascii=True, check_circular=True,
          cls=None, indent=None, separators=None,
          encoding='utf-8', default=None, use_decimal=True,
          namedtuple_as_object=True, tuple_as_array=True,
          bigint_as_string=False, sort_keys=False, item_sort_key=None,
          for_json=False, int_as_string_bitcount=None, **kw):
    """Serialize ``obj`` to a JSON formatted ``str``.

    If ``skipkeys`` is false then ``dict`` keys that are not basic types
    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)
    will be skipped instead of raising a ``TypeError``.

    If ``ensure_ascii`` is false, then the return value will be a
    ``unicode`` instance subject to normal Python ``str`` to ``unicode``
    coercion rules instead of being escaped to an ASCII ``str``.

    If ``check_circular`` is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``OverflowError`` (or worse).

    If ``indent`` is a string, then JSON array elements and object members
    will be pretty-printed with a newline followed by that string repeated
    for each level of nesting. ``None`` (the default) selects the most compact
    representation without any newlines. An integer is also accepted
    and is converted to a string with that many spaces.

    If specified, ``separators`` should be an
    ``(item_separator, key_separator)`` tuple.  The default is ``(', ', ': ')``
    if *indent* is ``None`` and ``(',', ': ')`` otherwise.  To get the most
    compact JSON representation, you should specify ``(',', ':')`` to eliminate
    whitespace.

    ``encoding`` is the character encoding for str instances, default is UTF-8.

    ``default(obj)`` is a function that should return a serializable version
    of obj or raise TypeError. The default simply raises TypeError.

    If *use_decimal* is true (default: ``True``) then decimal.Decimal
    will be natively serialized to JSON with full precision.

    If *namedtuple_as_object* is true (default: ``True``),
    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded
    as JSON objects.

    If *tuple_as_array* is true (default: ``True``),
    :class:`tuple` (and subclasses) will be encoded as JSON arrays.

    If *bigint_as_string* is true (not the default), ints 2**53 and higher
    or lower than -2**53 will be encoded as strings. This is to avoid the
    rounding that happens in Javascript otherwise.

    If *int_as_string_bitcount* is a positive number (n), then int of size
    greater than or equal to 2**n or lower than or equal to -2**n will be
    encoded as strings.

    If specified, *item_sort_key* is a callable used to sort the items in
    each dictionary. This is useful if you want to sort items other than
    in alphabetical order by key. This option takes precendence over
    *sort_keys*.

    If *sort_keys* is true (default: ``False``), the output of dictionaries
    will be sorted by item.

    If *for_json* is true (default: ``False``), objects with a ``for_json()``
    method will use the return value of that method for encoding as JSON
    instead of the object.

    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg. NOTE: You should use *default* instead of subclassing
    whenever possible.

    """
    # cached encoder
    if (
        not skipkeys and ensure_ascii and
        check_circular and
        cls is None and indent is None and separators is None and
        encoding == 'utf-8' and default is None and use_decimal
        and namedtuple_as_object and tuple_as_array
        and not bigint_as_string and not sort_keys
        and not item_sort_key and not for_json
        and int_as_string_bitcount is None
        and not kw
    ):
        return _default_json_encoder.encode(obj)
    if cls is None:
        cls = JSONEncoder
    return cls(
        skipkeys=skipkeys, ensure_ascii=ensure_ascii,
        check_circular=check_circular, indent=indent,
        separators=separators, encoding=encoding, default=default,
        use_decimal=use_decimal,
        namedtuple_as_object=namedtuple_as_object,
        tuple_as_array=tuple_as_array,
        bigint_as_string=bigint_as_string,
        sort_keys=sort_keys,
        item_sort_key=item_sort_key,
        for_json=for_json,
        int_as_string_bitcount=int_as_string_bitcount,
        **kw).encode(obj)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="hjson.load">
    <p>def <span class="ident">load</span>(</p><p>fp, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, object_pairs_hook=&lt;class &#39;collections.OrderedDict&#39;&gt;, use_decimal=False, namedtuple_as_object=True, tuple_as_array=True, **kw)</p>
    </div>
    

    
  
    <div class="desc"><p>Deserialize <code>fp</code> (a <code>.read()</code>-supporting file-like object containing
a JSON document) to a Python object.</p>
<p><em>encoding</em> determines the encoding used to interpret any
:class:<code>str</code> objects decoded by this instance (<code>'utf-8'</code> by
default).  It has no effect when decoding :class:<code>unicode</code> objects.</p>
<p>Note that currently only encodings that are a superset of ASCII work,
strings of other encodings should be passed in as :class:<code>unicode</code>.</p>
<p><em>object_hook</em>, if specified, will be called with the result of every
JSON object decoded and its return value will be used in place of the
given :class:<code>dict</code>.  This can be used to provide custom
deserializations (e.g. to support JSON-RPC class hinting).</p>
<p><em>object_pairs_hook</em> is an optional function that will be called with
the result of any object literal decode with an ordered list of pairs.
The return value of <em>object_pairs_hook</em> will be used instead of the
:class:<code>dict</code>.  This feature can be used to implement custom decoders
that rely on the order that the key and value pairs are decoded (for
example, :func:<code>collections.OrderedDict</code> will remember the order of
insertion). If <em>object_hook</em> is also defined, the <em>object_pairs_hook</em>
takes priority.</p>
<p><em>parse_float</em>, if specified, will be called with the string of every
JSON float to be decoded.  By default, this is equivalent to
<code>float(num_str)</code>. This can be used to use another datatype or parser
for JSON floats (e.g. :class:<code>decimal.Decimal</code>).</p>
<p><em>parse_int</em>, if specified, will be called with the string of every
JSON int to be decoded.  By default, this is equivalent to
<code>int(num_str)</code>.  This can be used to use another datatype or parser
for JSON integers (e.g. :class:<code>float</code>).</p>
<p>If <em>use_decimal</em> is true (default: <code>False</code>) then it implies
parse_float=decimal.Decimal for parity with <code>dump</code>.</p>
<p>To use a custom <code>HjsonDecoder</code> subclass, specify it with the <code>cls</code>
kwarg. NOTE: You should use <em>object_hook</em> or <em>object_pairs_hook</em> instead
of subclassing whenever possible.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.load', this);">Show source &equiv;</a></p>
  <div id="source-hjson.load" class="source">
    <pre><code>def load(fp, encoding=None, cls=None, object_hook=None, parse_float=None,
        parse_int=None, object_pairs_hook=OrderedDict,
        use_decimal=False, namedtuple_as_object=True, tuple_as_array=True,
        **kw):
    """Deserialize ``fp`` (a ``.read()``-supporting file-like object containing
    a JSON document) to a Python object.

    *encoding* determines the encoding used to interpret any
    :class:`str` objects decoded by this instance (``'utf-8'`` by
    default).  It has no effect when decoding :class:`unicode` objects.

    Note that currently only encodings that are a superset of ASCII work,
    strings of other encodings should be passed in as :class:`unicode`.

    *object_hook*, if specified, will be called with the result of every
    JSON object decoded and its return value will be used in place of the
    given :class:`dict`.  This can be used to provide custom
    deserializations (e.g. to support JSON-RPC class hinting).

    *object_pairs_hook* is an optional function that will be called with
    the result of any object literal decode with an ordered list of pairs.
    The return value of *object_pairs_hook* will be used instead of the
    :class:`dict`.  This feature can be used to implement custom decoders
    that rely on the order that the key and value pairs are decoded (for
    example, :func:`collections.OrderedDict` will remember the order of
    insertion). If *object_hook* is also defined, the *object_pairs_hook*
    takes priority.

    *parse_float*, if specified, will be called with the string of every
    JSON float to be decoded.  By default, this is equivalent to
    ``float(num_str)``. This can be used to use another datatype or parser
    for JSON floats (e.g. :class:`decimal.Decimal`).

    *parse_int*, if specified, will be called with the string of every
    JSON int to be decoded.  By default, this is equivalent to
    ``int(num_str)``.  This can be used to use another datatype or parser
    for JSON integers (e.g. :class:`float`).

    If *use_decimal* is true (default: ``False``) then it implies
    parse_float=decimal.Decimal for parity with ``dump``.

    To use a custom ``HjsonDecoder`` subclass, specify it with the ``cls``
    kwarg. NOTE: You should use *object_hook* or *object_pairs_hook* instead
    of subclassing whenever possible.

    """
    return loads(fp.read(),
        encoding=encoding, cls=cls, object_hook=object_hook,
        parse_float=parse_float, parse_int=parse_int,
        object_pairs_hook=object_pairs_hook,
        use_decimal=use_decimal, **kw)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="hjson.loads">
    <p>def <span class="ident">loads</span>(</p><p>s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, object_pairs_hook=None, use_decimal=False, **kw)</p>
    </div>
    

    
  
    <div class="desc"><p>Deserialize <code>s</code> (a <code>str</code> or <code>unicode</code> instance containing a JSON
document) to a Python object.</p>
<p><em>encoding</em> determines the encoding used to interpret any
:class:<code>str</code> objects decoded by this instance (<code>'utf-8'</code> by
default).  It has no effect when decoding :class:<code>unicode</code> objects.</p>
<p>Note that currently only encodings that are a superset of ASCII work,
strings of other encodings should be passed in as :class:<code>unicode</code>.</p>
<p><em>object_hook</em>, if specified, will be called with the result of every
JSON object decoded and its return value will be used in place of the
given :class:<code>dict</code>.  This can be used to provide custom
deserializations (e.g. to support JSON-RPC class hinting).</p>
<p><em>object_pairs_hook</em> is an optional function that will be called with
the result of any object literal decode with an ordered list of pairs.
The return value of <em>object_pairs_hook</em> will be used instead of the
:class:<code>dict</code>.  This feature can be used to implement custom decoders
that rely on the order that the key and value pairs are decoded (for
example, :func:<code>collections.OrderedDict</code> will remember the order of
insertion). If <em>object_hook</em> is also defined, the <em>object_pairs_hook</em>
takes priority.</p>
<p><em>parse_float</em>, if specified, will be called with the string of every
JSON float to be decoded.  By default, this is equivalent to
<code>float(num_str)</code>. This can be used to use another datatype or parser
for JSON floats (e.g. :class:<code>decimal.Decimal</code>).</p>
<p><em>parse_int</em>, if specified, will be called with the string of every
JSON int to be decoded.  By default, this is equivalent to
<code>int(num_str)</code>.  This can be used to use another datatype or parser
for JSON integers (e.g. :class:<code>float</code>).</p>
<p>If <em>use_decimal</em> is true (default: <code>False</code>) then it implies
parse_float=decimal.Decimal for parity with <code>dump</code>.</p>
<p>To use a custom <code>HjsonDecoder</code> subclass, specify it with the <code>cls</code>
kwarg. NOTE: You should use <em>object_hook</em> or <em>object_pairs_hook</em> instead
of subclassing whenever possible.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.loads', this);">Show source &equiv;</a></p>
  <div id="source-hjson.loads" class="source">
    <pre><code>def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None,
        parse_int=None, object_pairs_hook=None,
        use_decimal=False, **kw):
    """Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON
    document) to a Python object.

    *encoding* determines the encoding used to interpret any
    :class:`str` objects decoded by this instance (``'utf-8'`` by
    default).  It has no effect when decoding :class:`unicode` objects.

    Note that currently only encodings that are a superset of ASCII work,
    strings of other encodings should be passed in as :class:`unicode`.

    *object_hook*, if specified, will be called with the result of every
    JSON object decoded and its return value will be used in place of the
    given :class:`dict`.  This can be used to provide custom
    deserializations (e.g. to support JSON-RPC class hinting).

    *object_pairs_hook* is an optional function that will be called with
    the result of any object literal decode with an ordered list of pairs.
    The return value of *object_pairs_hook* will be used instead of the
    :class:`dict`.  This feature can be used to implement custom decoders
    that rely on the order that the key and value pairs are decoded (for
    example, :func:`collections.OrderedDict` will remember the order of
    insertion). If *object_hook* is also defined, the *object_pairs_hook*
    takes priority.

    *parse_float*, if specified, will be called with the string of every
    JSON float to be decoded.  By default, this is equivalent to
    ``float(num_str)``. This can be used to use another datatype or parser
    for JSON floats (e.g. :class:`decimal.Decimal`).

    *parse_int*, if specified, will be called with the string of every
    JSON int to be decoded.  By default, this is equivalent to
    ``int(num_str)``.  This can be used to use another datatype or parser
    for JSON integers (e.g. :class:`float`).

    If *use_decimal* is true (default: ``False``) then it implies
    parse_float=decimal.Decimal for parity with ``dump``.

    To use a custom ``HjsonDecoder`` subclass, specify it with the ``cls``
    kwarg. NOTE: You should use *object_hook* or *object_pairs_hook* instead
    of subclassing whenever possible.

    """
    if (cls is None and encoding is None and object_hook is None and
            parse_int is None and parse_float is None and
            object_pairs_hook is None
            and not use_decimal and not kw):
        return _default_decoder.decode(s)
    if cls is None:
        cls = HjsonDecoder
    if object_hook is not None:
        kw['object_hook'] = object_hook
    if object_pairs_hook is not None:
        kw['object_pairs_hook'] = object_pairs_hook
    if parse_float is not None:
        kw['parse_float'] = parse_float
    if parse_int is not None:
        kw['parse_int'] = parse_int
    if use_decimal:
        if parse_float is not None:
            raise TypeError("use_decimal=True implies parse_float=Decimal")
        kw['parse_float'] = Decimal
    return cls(encoding=encoding, **kw).decode(s)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="hjson.simple_first">
    <p>def <span class="ident">simple_first</span>(</p><p>kv)</p>
    </div>
    

    
  
    <div class="desc"><p>Helper function to pass to item_sort_key to sort simple
elements to the top, then container elements.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.simple_first', this);">Show source &equiv;</a></p>
  <div id="source-hjson.simple_first" class="source">
    <pre><code>def simple_first(kv):
    """Helper function to pass to item_sort_key to sort simple
    elements to the top, then container elements.
    """
    return (isinstance(kv[1], (list, dict, tuple)), kv[0])
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="hjson.HjsonDecodeError" class="name">class <span class="ident">HjsonDecodeError</span></p>
      
  
    <div class="desc"><p>Subclass of ValueError with the following additional properties:</p>
<p>msg: The unformatted error message
doc: The JSON document being parsed
pos: The start index of doc where parsing failed
end: The end index of doc where parsing failed (may be None)
lineno: The line corresponding to pos
colno: The column corresponding to pos
endlineno: The line corresponding to end (may be None)
endcolno: The column corresponding to end (may be None)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.HjsonDecodeError', this);">Show source &equiv;</a></p>
  <div id="source-hjson.HjsonDecodeError" class="source">
    <pre><code>class HjsonDecodeError(ValueError):
    """Subclass of ValueError with the following additional properties:

    msg: The unformatted error message
    doc: The JSON document being parsed
    pos: The start index of doc where parsing failed
    end: The end index of doc where parsing failed (may be None)
    lineno: The line corresponding to pos
    colno: The column corresponding to pos
    endlineno: The line corresponding to end (may be None)
    endcolno: The column corresponding to end (may be None)

    """
    # Note that this exception is used from _speedups
    def __init__(self, msg, doc, pos, end=None):
        ValueError.__init__(self, errmsg(msg, doc, pos, end=end))
        self.msg = msg
        self.doc = doc
        self.pos = pos
        self.end = end
        self.lineno, self.colno = linecol(doc, pos)
        if end is not None:
            self.endlineno, self.endcolno = linecol(doc, end)
        else:
            self.endlineno, self.endcolno = None, None

    def __reduce__(self):
        return self.__class__, (self.msg, self.doc, self.pos, self.end)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#hjson.HjsonDecodeError">HjsonDecodeError</a></li>
          <li>exceptions.ValueError</li>
          <li>exceptions.StandardError</li>
          <li>exceptions.Exception</li>
          <li>exceptions.BaseException</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="hjson.HjsonDecodeError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecodeError.message" class="name">var <span class="ident">message</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="hjson.HjsonDecodeError.doc" class="name">var <span class="ident">doc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecodeError.end" class="name">var <span class="ident">end</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecodeError.msg" class="name">var <span class="ident">msg</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecodeError.pos" class="name">var <span class="ident">pos</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="hjson.HjsonDecodeError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, msg, doc, pos, end=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.HjsonDecodeError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-hjson.HjsonDecodeError.__init__" class="source">
    <pre><code>def __init__(self, msg, doc, pos, end=None):
    ValueError.__init__(self, errmsg(msg, doc, pos, end=end))
    self.msg = msg
    self.doc = doc
    self.pos = pos
    self.end = end
    self.lineno, self.colno = linecol(doc, pos)
    if end is not None:
        self.endlineno, self.endcolno = linecol(doc, end)
    else:
        self.endlineno, self.endcolno = None, None
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="hjson.HjsonDecoder" class="name">class <span class="ident">HjsonDecoder</span></p>
      
  
    <div class="desc"><p>Hjson decoder</p>
<p>Performs the following translations in decoding by default:</p>
<p>+---------------+-------------------+
| JSON          | Python            |
+===============+===================+
| object        | dict              |
+---------------+-------------------+
| array         | list              |
+---------------+-------------------+
| string        | str, unicode      |
+---------------+-------------------+
| number (int)  | int, long         |
+---------------+-------------------+
| number (real) | float             |
+---------------+-------------------+
| true          | True              |
+---------------+-------------------+
| false         | False             |
+---------------+-------------------+
| null          | None              |
+---------------+-------------------+</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.HjsonDecoder', this);">Show source &equiv;</a></p>
  <div id="source-hjson.HjsonDecoder" class="source">
    <pre><code>class HjsonDecoder(object):
    """Hjson decoder

    Performs the following translations in decoding by default:

    +---------------+-------------------+
    | JSON          | Python            |
    +===============+===================+
    | object        | dict              |
    +---------------+-------------------+
    | array         | list              |
    +---------------+-------------------+
    | string        | str, unicode      |
    +---------------+-------------------+
    | number (int)  | int, long         |
    +---------------+-------------------+
    | number (real) | float             |
    +---------------+-------------------+
    | true          | True              |
    +---------------+-------------------+
    | false         | False             |
    +---------------+-------------------+
    | null          | None              |
    +---------------+-------------------+

    """

    def __init__(self, encoding=None, object_hook=None, parse_float=None,
            parse_int=None, strict=True,
            object_pairs_hook=None):
        """
        *encoding* determines the encoding used to interpret any
        :class:`str` objects decoded by this instance (``'utf-8'`` by
        default).  It has no effect when decoding :class:`unicode` objects.

        Note that currently only encodings that are a superset of ASCII work,
        strings of other encodings should be passed in as :class:`unicode`.

        *object_hook*, if specified, will be called with the result of every
        JSON object decoded and its return value will be used in place of the
        given :class:`dict`.  This can be used to provide custom
        deserializations (e.g. to support JSON-RPC class hinting).

        *object_pairs_hook* is an optional function that will be called with
        the result of any object literal decode with an ordered list of pairs.
        The return value of *object_pairs_hook* will be used instead of the
        :class:`dict`.  This feature can be used to implement custom decoders
        that rely on the order that the key and value pairs are decoded (for
        example, :func:`collections.OrderedDict` will remember the order of
        insertion). If *object_hook* is also defined, the *object_pairs_hook*
        takes priority.

        *parse_float*, if specified, will be called with the string of every
        JSON float to be decoded.  By default, this is equivalent to
        ``float(num_str)``. This can be used to use another datatype or parser
        for JSON floats (e.g. :class:`decimal.Decimal`).

        *parse_int*, if specified, will be called with the string of every
        JSON int to be decoded.  By default, this is equivalent to
        ``int(num_str)``.  This can be used to use another datatype or parser
        for JSON integers (e.g. :class:`float`).

        *strict* controls the parser's behavior when it encounters an
        invalid control character in a string. The default setting of
        ``True`` means that unescaped control characters are parse errors, if
        ``False`` then control characters will be allowed in strings.

        """
        if encoding is None:
            encoding = DEFAULT_ENCODING
        self.encoding = encoding
        self.object_hook = object_hook
        self.object_pairs_hook = object_pairs_hook
        self.parse_float = parse_float or float
        self.parse_int = parse_int or int
        self.strict = strict
        self.parse_object = JSONObject
        self.parse_array = JSONArray
        self.parse_string = scanstring
        self.parse_mlstring = mlscanstring
        self.parse_tfnns = scantfnns
        self.memo = {}
        (self.scan_once, self.scan_object_once) = make_scanner(self)

    def decode(self, s, _PY3=PY3):
        """Return the Python representation of ``s`` (a ``str`` or ``unicode``
        instance containing a JSON document)

        """
        if _PY3 and isinstance(s, binary_type):
            s = s.decode(self.encoding)
        obj, end = self.raw_decode(s)
        ch, end = getNext(s, end)
        if end != len(s):
            raise HjsonDecodeError("Extra data", s, end, len(s))
        return obj

    def raw_decode(self, s, idx=0, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.

        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.

        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise HjsonDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, text_type):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3

        ch, idx = getNext(s, idx)

        if ch == '{' or ch == '[':
            return self.scan_once(s, idx)
        else:
            # assume we have a root object without braces
            try:
                return self.scan_object_once(s, idx)
            except HjsonDecodeError as e:
                # test if we are dealing with a single JSON value instead (true/false/null/num/"")
                try:
                    return self.scan_once(s, idx)
                except:
                    raise e
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#hjson.HjsonDecoder">HjsonDecoder</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="hjson.HjsonDecoder.encoding" class="name">var <span class="ident">encoding</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecoder.memo" class="name">var <span class="ident">memo</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecoder.object_hook" class="name">var <span class="ident">object_hook</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecoder.object_pairs_hook" class="name">var <span class="ident">object_pairs_hook</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecoder.parse_array" class="name">var <span class="ident">parse_array</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecoder.parse_float" class="name">var <span class="ident">parse_float</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecoder.parse_int" class="name">var <span class="ident">parse_int</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecoder.parse_mlstring" class="name">var <span class="ident">parse_mlstring</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecoder.parse_object" class="name">var <span class="ident">parse_object</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecoder.parse_string" class="name">var <span class="ident">parse_string</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecoder.parse_tfnns" class="name">var <span class="ident">parse_tfnns</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonDecoder.strict" class="name">var <span class="ident">strict</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="hjson.HjsonDecoder.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, encoding=None, object_hook=None, parse_float=None, parse_int=None, strict=True, object_pairs_hook=None)</p>
    </div>
    

    
  
    <div class="desc"><p><em>encoding</em> determines the encoding used to interpret any
:class:<code>str</code> objects decoded by this instance (<code>'utf-8'</code> by
default).  It has no effect when decoding :class:<code>unicode</code> objects.</p>
<p>Note that currently only encodings that are a superset of ASCII work,
strings of other encodings should be passed in as :class:<code>unicode</code>.</p>
<p><em>object_hook</em>, if specified, will be called with the result of every
JSON object decoded and its return value will be used in place of the
given :class:<code>dict</code>.  This can be used to provide custom
deserializations (e.g. to support JSON-RPC class hinting).</p>
<p><em>object_pairs_hook</em> is an optional function that will be called with
the result of any object literal decode with an ordered list of pairs.
The return value of <em>object_pairs_hook</em> will be used instead of the
:class:<code>dict</code>.  This feature can be used to implement custom decoders
that rely on the order that the key and value pairs are decoded (for
example, :func:<code>collections.OrderedDict</code> will remember the order of
insertion). If <em>object_hook</em> is also defined, the <em>object_pairs_hook</em>
takes priority.</p>
<p><em>parse_float</em>, if specified, will be called with the string of every
JSON float to be decoded.  By default, this is equivalent to
<code>float(num_str)</code>. This can be used to use another datatype or parser
for JSON floats (e.g. :class:<code>decimal.Decimal</code>).</p>
<p><em>parse_int</em>, if specified, will be called with the string of every
JSON int to be decoded.  By default, this is equivalent to
<code>int(num_str)</code>.  This can be used to use another datatype or parser
for JSON integers (e.g. :class:<code>float</code>).</p>
<p><em>strict</em> controls the parser's behavior when it encounters an
invalid control character in a string. The default setting of
<code>True</code> means that unescaped control characters are parse errors, if
<code>False</code> then control characters will be allowed in strings.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.HjsonDecoder.__init__', this);">Show source &equiv;</a></p>
  <div id="source-hjson.HjsonDecoder.__init__" class="source">
    <pre><code>def __init__(self, encoding=None, object_hook=None, parse_float=None,
        parse_int=None, strict=True,
        object_pairs_hook=None):
    """
    *encoding* determines the encoding used to interpret any
    :class:`str` objects decoded by this instance (``'utf-8'`` by
    default).  It has no effect when decoding :class:`unicode` objects.
    Note that currently only encodings that are a superset of ASCII work,
    strings of other encodings should be passed in as :class:`unicode`.
    *object_hook*, if specified, will be called with the result of every
    JSON object decoded and its return value will be used in place of the
    given :class:`dict`.  This can be used to provide custom
    deserializations (e.g. to support JSON-RPC class hinting).
    *object_pairs_hook* is an optional function that will be called with
    the result of any object literal decode with an ordered list of pairs.
    The return value of *object_pairs_hook* will be used instead of the
    :class:`dict`.  This feature can be used to implement custom decoders
    that rely on the order that the key and value pairs are decoded (for
    example, :func:`collections.OrderedDict` will remember the order of
    insertion). If *object_hook* is also defined, the *object_pairs_hook*
    takes priority.
    *parse_float*, if specified, will be called with the string of every
    JSON float to be decoded.  By default, this is equivalent to
    ``float(num_str)``. This can be used to use another datatype or parser
    for JSON floats (e.g. :class:`decimal.Decimal`).
    *parse_int*, if specified, will be called with the string of every
    JSON int to be decoded.  By default, this is equivalent to
    ``int(num_str)``.  This can be used to use another datatype or parser
    for JSON integers (e.g. :class:`float`).
    *strict* controls the parser's behavior when it encounters an
    invalid control character in a string. The default setting of
    ``True`` means that unescaped control characters are parse errors, if
    ``False`` then control characters will be allowed in strings.
    """
    if encoding is None:
        encoding = DEFAULT_ENCODING
    self.encoding = encoding
    self.object_hook = object_hook
    self.object_pairs_hook = object_pairs_hook
    self.parse_float = parse_float or float
    self.parse_int = parse_int or int
    self.strict = strict
    self.parse_object = JSONObject
    self.parse_array = JSONArray
    self.parse_string = scanstring
    self.parse_mlstring = mlscanstring
    self.parse_tfnns = scantfnns
    self.memo = {}
    (self.scan_once, self.scan_object_once) = make_scanner(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.HjsonDecoder.decode">
    <p>def <span class="ident">decode</span>(</p><p>self, s, _PY3=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the Python representation of <code>s</code> (a <code>str</code> or <code>unicode</code>
instance containing a JSON document)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.HjsonDecoder.decode', this);">Show source &equiv;</a></p>
  <div id="source-hjson.HjsonDecoder.decode" class="source">
    <pre><code>def decode(self, s, _PY3=PY3):
    """Return the Python representation of ``s`` (a ``str`` or ``unicode``
    instance containing a JSON document)
    """
    if _PY3 and isinstance(s, binary_type):
        s = s.decode(self.encoding)
    obj, end = self.raw_decode(s)
    ch, end = getNext(s, end)
    if end != len(s):
        raise HjsonDecodeError("Extra data", s, end, len(s))
    return obj
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.HjsonDecoder.raw_decode">
    <p>def <span class="ident">raw_decode</span>(</p><p>self, s, idx=0, _PY3=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Decode a JSON document from <code>s</code> (a <code>str</code> or <code>unicode</code>
beginning with a JSON document) and return a 2-tuple of the Python
representation and the index in <code>s</code> where the document ended.
Optionally, <code>idx</code> can be used to specify an offset in <code>s</code> where
the JSON document begins.</p>
<p>This can be used to decode a JSON document from a string that may
have extraneous data at the end.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.HjsonDecoder.raw_decode', this);">Show source &equiv;</a></p>
  <div id="source-hjson.HjsonDecoder.raw_decode" class="source">
    <pre><code>def raw_decode(self, s, idx=0, _PY3=PY3):
    """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
    beginning with a JSON document) and return a 2-tuple of the Python
    representation and the index in ``s`` where the document ended.
    Optionally, ``idx`` can be used to specify an offset in ``s`` where
    the JSON document begins.
    This can be used to decode a JSON document from a string that may
    have extraneous data at the end.
    """
    if idx < 0:
        # Ensure that raw_decode bails on negative indexes, the regex
        # would otherwise mask this behavior. #98
        raise HjsonDecodeError('Expecting value', s, idx)
    if _PY3 and not isinstance(s, text_type):
        raise TypeError("Input string must be text, not bytes")
    # strip UTF-8 bom
    if len(s) > idx:
        ord0 = ord(s[idx])
        if ord0 == 0xfeff:
            idx += 1
        elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
            idx += 3
    ch, idx = getNext(s, idx)
    if ch == '{' or ch == '[':
        return self.scan_once(s, idx)
    else:
        # assume we have a root object without braces
        try:
            return self.scan_object_once(s, idx)
        except HjsonDecodeError as e:
            # test if we are dealing with a single JSON value instead (true/false/null/num/"")
            try:
                return self.scan_once(s, idx)
            except:
                raise e
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="hjson.HjsonEncoder" class="name">class <span class="ident">HjsonEncoder</span></p>
      
  
    <div class="desc"><p>Extensible JSON <a href="http://json.org">http://json.org</a> encoder for Python data structures.</p>
<p>Supports the following objects and types by default:</p>
<p>+-------------------+---------------+
| Python            | JSON          |
+===================+===============+
| dict, namedtuple  | object        |
+-------------------+---------------+
| list, tuple       | array         |
+-------------------+---------------+
| str, unicode      | string        |
+-------------------+---------------+
| int, long, float  | number        |
+-------------------+---------------+
| True              | true          |
+-------------------+---------------+
| False             | false         |
+-------------------+---------------+
| None              | null          |
+-------------------+---------------+</p>
<p>To extend this to recognize other objects, subclass and implement a
<code>.default()</code> method with another method that returns a serializable
object for <code>o</code> if possible, otherwise it should call the superclass
implementation (to raise <code>TypeError</code>).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.HjsonEncoder', this);">Show source &equiv;</a></p>
  <div id="source-hjson.HjsonEncoder" class="source">
    <pre><code>class HjsonEncoder(object):
    """Extensible JSON <http://json.org> encoder for Python data structures.

    Supports the following objects and types by default:

    +-------------------+---------------+
    | Python            | JSON          |
    +===================+===============+
    | dict, namedtuple  | object        |
    +-------------------+---------------+
    | list, tuple       | array         |
    +-------------------+---------------+
    | str, unicode      | string        |
    +-------------------+---------------+
    | int, long, float  | number        |
    +-------------------+---------------+
    | True              | true          |
    +-------------------+---------------+
    | False             | false         |
    +-------------------+---------------+
    | None              | null          |
    +-------------------+---------------+

    To extend this to recognize other objects, subclass and implement a
    ``.default()`` method with another method that returns a serializable
    object for ``o`` if possible, otherwise it should call the superclass
    implementation (to raise ``TypeError``).

    """

    def __init__(self, skipkeys=False, ensure_ascii=True,
                 check_circular=True, sort_keys=False,
                 indent='  ', encoding='utf-8', default=None,
                 use_decimal=True, namedtuple_as_object=True,
                 tuple_as_array=True, bigint_as_string=False,
                 item_sort_key=None, for_json=False,
                 int_as_string_bitcount=None):
        """Constructor for HjsonEncoder, with sensible defaults.

        If skipkeys is false, then it is a TypeError to attempt
        encoding of keys that are not str, int, long, float or None.  If
        skipkeys is True, such items are simply skipped.

        If ensure_ascii is true, the output is guaranteed to be str
        objects with all incoming unicode characters escaped.  If
        ensure_ascii is false, the output will be unicode object.

        If check_circular is true, then lists, dicts, and custom encoded
        objects will be checked for circular references during encoding to
        prevent an infinite recursion (which would cause an OverflowError).
        Otherwise, no such check takes place.

        If sort_keys is true, then the output of dictionaries will be
        sorted by key; this is useful for regression tests to ensure
        that JSON serializations can be compared on a day-to-day basis.

        If indent is a string, then JSON array elements and object members
        will be pretty-printed with a newline followed by that string repeated
        for each level of nesting.

        If specified, default is a function that gets called for objects
        that can't otherwise be serialized.  It should return a JSON encodable
        version of the object or raise a ``TypeError``.

        If encoding is not None, then all input strings will be
        transformed into unicode using that encoding prior to JSON-encoding.
        The default is UTF-8.

        If use_decimal is true (not the default), ``decimal.Decimal`` will
        be supported directly by the encoder. For the inverse, decode JSON
        with ``parse_float=decimal.Decimal``.

        If namedtuple_as_object is true (the default), objects with
        ``_asdict()`` methods will be encoded as JSON objects.

        If tuple_as_array is true (the default), tuple (and subclasses) will
        be encoded as JSON arrays.

        If bigint_as_string is true (not the default), ints 2**53 and higher
        or lower than -2**53 will be encoded as strings. This is to avoid the
        rounding that happens in Javascript otherwise.

        If int_as_string_bitcount is a positive number (n), then int of size
        greater than or equal to 2**n or lower than or equal to -2**n will be
        encoded as strings.

        If specified, item_sort_key is a callable used to sort the items in
        each dictionary. This is useful if you want to sort items other than
        in alphabetical order by key.

        If for_json is true (not the default), objects with a ``for_json()``
        method will use the return value of that method for encoding as JSON
        instead of the object.

        """

        self.skipkeys = skipkeys
        self.ensure_ascii = ensure_ascii
        self.check_circular = check_circular
        self.sort_keys = sort_keys
        self.use_decimal = use_decimal
        self.namedtuple_as_object = namedtuple_as_object
        self.tuple_as_array = tuple_as_array
        self.bigint_as_string = bigint_as_string
        self.item_sort_key = item_sort_key
        self.for_json = for_json
        self.int_as_string_bitcount = int_as_string_bitcount
        if indent is not None and not isinstance(indent, string_types):
            indent = indent * ' '
        elif indent is None:
            indent = '  '
        self.indent = indent
        if default is not None:
            self.default = default
        self.encoding = encoding

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).

        For example, to support arbitrary iterators, you could
        implement default like this::

            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                return HjsonEncoder.default(self, o)

        """
        raise TypeError(repr(o) + " is not JSON serializable")

    def encode(self, o):
        """Return a JSON string representation of a Python data structure.

        >>> from hjson import HjsonEncoder
        >>> HjsonEncoder().encode({"foo": ["bar", "baz"]})
        '{"foo": ["bar", "baz"]}'

        """
        # This is for extremely simple cases and benchmarks.
        if isinstance(o, binary_type):
            _encoding = self.encoding
            if (_encoding is not None and not (_encoding == 'utf-8')):
                o = o.decode(_encoding)

        # This doesn't pass the iterator directly to ''.join() because the
        # exceptions aren't as detailed.  The list call should be roughly
        # equivalent to the PySequence_Fast that ''.join() would do.
        chunks = self.iterencode(o, _one_shot=True)
        if not isinstance(chunks, (list, tuple)):
            chunks = list(chunks)
        if self.ensure_ascii:
            return ''.join(chunks)
        else:
            return u''.join(chunks)

    def iterencode(self, o, _one_shot=False):
        """Encode the given object and yield each string
        representation as available.

        For example::

            for chunk in HjsonEncoder().iterencode(bigobject):
                mysocket.write(chunk)

        """
        if self.check_circular:
            markers = {}
        else:
            markers = None
        if self.ensure_ascii:
            _encoder = encode_basestring_ascii
        else:
            _encoder = encode_basestring
        if self.encoding != 'utf-8':
            def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
                if isinstance(o, binary_type):
                    o = o.decode(_encoding)
                return _orig_encoder(o)

        def floatstr(o, _repr=FLOAT_REPR, _inf=PosInf, _neginf=-PosInf):
            # Check for specials. Note that this type of test is processor
            # and/or platform-specific, so do tests which don't depend on
            # the internals.

            if o != o or o == _inf or o == _neginf:
                return 'null'
            else:
                return _repr(o)

        key_memo = {}
        int_as_string_bitcount = (
            53 if self.bigint_as_string else self.int_as_string_bitcount)
        _iterencode = _make_iterencode(
            markers, self.default, _encoder, self.indent, floatstr,
            self.sort_keys, self.skipkeys, _one_shot, self.use_decimal,
            self.namedtuple_as_object, self.tuple_as_array,
            int_as_string_bitcount,
            self.item_sort_key, self.encoding, self.for_json,
            Decimal=Decimal)
        try:
            return _iterencode(o, 0, True)
        finally:
            key_memo.clear()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#hjson.HjsonEncoder">HjsonEncoder</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="hjson.HjsonEncoder.bigint_as_string" class="name">var <span class="ident">bigint_as_string</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.check_circular" class="name">var <span class="ident">check_circular</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.encoding" class="name">var <span class="ident">encoding</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.ensure_ascii" class="name">var <span class="ident">ensure_ascii</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.for_json" class="name">var <span class="ident">for_json</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.indent" class="name">var <span class="ident">indent</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.int_as_string_bitcount" class="name">var <span class="ident">int_as_string_bitcount</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.item_sort_key" class="name">var <span class="ident">item_sort_key</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.namedtuple_as_object" class="name">var <span class="ident">namedtuple_as_object</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.skipkeys" class="name">var <span class="ident">skipkeys</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.sort_keys" class="name">var <span class="ident">sort_keys</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.tuple_as_array" class="name">var <span class="ident">tuple_as_array</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.HjsonEncoder.use_decimal" class="name">var <span class="ident">use_decimal</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="hjson.HjsonEncoder.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, skipkeys=False, ensure_ascii=True, check_circular=True, sort_keys=False, indent=&#39;  &#39;, encoding=&#39;utf-8&#39;, default=None, use_decimal=True, namedtuple_as_object=True, tuple_as_array=True, bigint_as_string=False, item_sort_key=None, for_json=False, int_as_string_bitcount=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor for HjsonEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, long, float or None.  If
skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming unicode characters escaped.  If
ensure_ascii is false, the output will be unicode object.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an OverflowError).
Otherwise, no such check takes place.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a string, then JSON array elements and object members
will be pretty-printed with a newline followed by that string repeated
for each level of nesting.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.  It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p>
<p>If encoding is not None, then all input strings will be
transformed into unicode using that encoding prior to JSON-encoding.
The default is UTF-8.</p>
<p>If use_decimal is true (not the default), <code>decimal.Decimal</code> will
be supported directly by the encoder. For the inverse, decode JSON
with <code>parse_float=decimal.Decimal</code>.</p>
<p>If namedtuple_as_object is true (the default), objects with
<code>_asdict()</code> methods will be encoded as JSON objects.</p>
<p>If tuple_as_array is true (the default), tuple (and subclasses) will
be encoded as JSON arrays.</p>
<p>If bigint_as_string is true (not the default), ints 2<strong>53 and higher
or lower than -2</strong>53 will be encoded as strings. This is to avoid the
rounding that happens in Javascript otherwise.</p>
<p>If int_as_string_bitcount is a positive number (n), then int of size
greater than or equal to 2<strong>n or lower than or equal to -2</strong>n will be
encoded as strings.</p>
<p>If specified, item_sort_key is a callable used to sort the items in
each dictionary. This is useful if you want to sort items other than
in alphabetical order by key.</p>
<p>If for_json is true (not the default), objects with a <code>for_json()</code>
method will use the return value of that method for encoding as JSON
instead of the object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.HjsonEncoder.__init__', this);">Show source &equiv;</a></p>
  <div id="source-hjson.HjsonEncoder.__init__" class="source">
    <pre><code>def __init__(self, skipkeys=False, ensure_ascii=True,
             check_circular=True, sort_keys=False,
             indent='  ', encoding='utf-8', default=None,
             use_decimal=True, namedtuple_as_object=True,
             tuple_as_array=True, bigint_as_string=False,
             item_sort_key=None, for_json=False,
             int_as_string_bitcount=None):
    """Constructor for HjsonEncoder, with sensible defaults.
    If skipkeys is false, then it is a TypeError to attempt
    encoding of keys that are not str, int, long, float or None.  If
    skipkeys is True, such items are simply skipped.
    If ensure_ascii is true, the output is guaranteed to be str
    objects with all incoming unicode characters escaped.  If
    ensure_ascii is false, the output will be unicode object.
    If check_circular is true, then lists, dicts, and custom encoded
    objects will be checked for circular references during encoding to
    prevent an infinite recursion (which would cause an OverflowError).
    Otherwise, no such check takes place.
    If sort_keys is true, then the output of dictionaries will be
    sorted by key; this is useful for regression tests to ensure
    that JSON serializations can be compared on a day-to-day basis.
    If indent is a string, then JSON array elements and object members
    will be pretty-printed with a newline followed by that string repeated
    for each level of nesting.
    If specified, default is a function that gets called for objects
    that can't otherwise be serialized.  It should return a JSON encodable
    version of the object or raise a ``TypeError``.
    If encoding is not None, then all input strings will be
    transformed into unicode using that encoding prior to JSON-encoding.
    The default is UTF-8.
    If use_decimal is true (not the default), ``decimal.Decimal`` will
    be supported directly by the encoder. For the inverse, decode JSON
    with ``parse_float=decimal.Decimal``.
    If namedtuple_as_object is true (the default), objects with
    ``_asdict()`` methods will be encoded as JSON objects.
    If tuple_as_array is true (the default), tuple (and subclasses) will
    be encoded as JSON arrays.
    If bigint_as_string is true (not the default), ints 2**53 and higher
    or lower than -2**53 will be encoded as strings. This is to avoid the
    rounding that happens in Javascript otherwise.
    If int_as_string_bitcount is a positive number (n), then int of size
    greater than or equal to 2**n or lower than or equal to -2**n will be
    encoded as strings.
    If specified, item_sort_key is a callable used to sort the items in
    each dictionary. This is useful if you want to sort items other than
    in alphabetical order by key.
    If for_json is true (not the default), objects with a ``for_json()``
    method will use the return value of that method for encoding as JSON
    instead of the object.
    """
    self.skipkeys = skipkeys
    self.ensure_ascii = ensure_ascii
    self.check_circular = check_circular
    self.sort_keys = sort_keys
    self.use_decimal = use_decimal
    self.namedtuple_as_object = namedtuple_as_object
    self.tuple_as_array = tuple_as_array
    self.bigint_as_string = bigint_as_string
    self.item_sort_key = item_sort_key
    self.for_json = for_json
    self.int_as_string_bitcount = int_as_string_bitcount
    if indent is not None and not isinstance(indent, string_types):
        indent = indent * ' '
    elif indent is None:
        indent = '  '
    self.indent = indent
    if default is not None:
        self.default = default
    self.encoding = encoding
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.HjsonEncoder.default">
    <p>def <span class="ident">default</span>(</p><p>self, o)</p>
    </div>
    

    
  
    <div class="desc"><p>Implement this method in a subclass such that it returns
a serializable object for <code>o</code>, or calls the base implementation
(to raise a <code>TypeError</code>).</p>
<p>For example, to support arbitrary iterators, you could
implement default like this::</p>
<pre><code>def default(self, o):
    try:
        iterable = iter(o)
    except TypeError:
        pass
    else:
        return list(iterable)
    return HjsonEncoder.default(self, o)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.HjsonEncoder.default', this);">Show source &equiv;</a></p>
  <div id="source-hjson.HjsonEncoder.default" class="source">
    <pre><code>def default(self, o):
    """Implement this method in a subclass such that it returns
    a serializable object for ``o``, or calls the base implementation
    (to raise a ``TypeError``).
    For example, to support arbitrary iterators, you could
    implement default like this::
        def default(self, o):
            try:
                iterable = iter(o)
            except TypeError:
                pass
            else:
                return list(iterable)
            return HjsonEncoder.default(self, o)
    """
    raise TypeError(repr(o) + " is not JSON serializable")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.HjsonEncoder.encode">
    <p>def <span class="ident">encode</span>(</p><p>self, o)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a JSON string representation of a Python data structure.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from hjson import HjsonEncoder
HjsonEncoder().encode({"foo": ["bar", "baz"]})
'{"foo": ["bar", "baz"]}'</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.HjsonEncoder.encode', this);">Show source &equiv;</a></p>
  <div id="source-hjson.HjsonEncoder.encode" class="source">
    <pre><code>def encode(self, o):
    """Return a JSON string representation of a Python data structure.
    >>> from hjson import HjsonEncoder
    >>> HjsonEncoder().encode({"foo": ["bar", "baz"]})
    '{"foo": ["bar", "baz"]}'
    """
    # This is for extremely simple cases and benchmarks.
    if isinstance(o, binary_type):
        _encoding = self.encoding
        if (_encoding is not None and not (_encoding == 'utf-8')):
            o = o.decode(_encoding)
    # This doesn't pass the iterator directly to ''.join() because the
    # exceptions aren't as detailed.  The list call should be roughly
    # equivalent to the PySequence_Fast that ''.join() would do.
    chunks = self.iterencode(o, _one_shot=True)
    if not isinstance(chunks, (list, tuple)):
        chunks = list(chunks)
    if self.ensure_ascii:
        return ''.join(chunks)
    else:
        return u''.join(chunks)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.HjsonEncoder.iterencode">
    <p>def <span class="ident">iterencode</span>(</p><p>self, o, _one_shot=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Encode the given object and yield each string
representation as available.</p>
<p>For example::</p>
<pre><code>for chunk in HjsonEncoder().iterencode(bigobject):
    mysocket.write(chunk)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.HjsonEncoder.iterencode', this);">Show source &equiv;</a></p>
  <div id="source-hjson.HjsonEncoder.iterencode" class="source">
    <pre><code>def iterencode(self, o, _one_shot=False):
    """Encode the given object and yield each string
    representation as available.
    For example::
        for chunk in HjsonEncoder().iterencode(bigobject):
            mysocket.write(chunk)
    """
    if self.check_circular:
        markers = {}
    else:
        markers = None
    if self.ensure_ascii:
        _encoder = encode_basestring_ascii
    else:
        _encoder = encode_basestring
    if self.encoding != 'utf-8':
        def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
            if isinstance(o, binary_type):
                o = o.decode(_encoding)
            return _orig_encoder(o)
    def floatstr(o, _repr=FLOAT_REPR, _inf=PosInf, _neginf=-PosInf):
        # Check for specials. Note that this type of test is processor
        # and/or platform-specific, so do tests which don't depend on
        # the internals.
        if o != o or o == _inf or o == _neginf:
            return 'null'
        else:
            return _repr(o)
    key_memo = {}
    int_as_string_bitcount = (
        53 if self.bigint_as_string else self.int_as_string_bitcount)
    _iterencode = _make_iterencode(
        markers, self.default, _encoder, self.indent, floatstr,
        self.sort_keys, self.skipkeys, _one_shot, self.use_decimal,
        self.namedtuple_as_object, self.tuple_as_array,
        int_as_string_bitcount,
        self.item_sort_key, self.encoding, self.for_json,
        Decimal=Decimal)
    try:
        return _iterencode(o, 0, True)
    finally:
        key_memo.clear()
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="hjson.JSONEncoder" class="name">class <span class="ident">JSONEncoder</span></p>
      
  
    <div class="desc"><p>Extensible JSON <a href="http://json.org">http://json.org</a> encoder for Python data structures.</p>
<p>Supports the following objects and types by default:</p>
<p>+-------------------+---------------+
| Python            | JSON          |
+===================+===============+
| dict, namedtuple  | object        |
+-------------------+---------------+
| list, tuple       | array         |
+-------------------+---------------+
| str, unicode      | string        |
+-------------------+---------------+
| int, long, float  | number        |
+-------------------+---------------+
| True              | true          |
+-------------------+---------------+
| False             | false         |
+-------------------+---------------+
| None              | null          |
+-------------------+---------------+</p>
<p>To extend this to recognize other objects, subclass and implement a
<code>.default()</code> method with another method that returns a serializable
object for <code>o</code> if possible, otherwise it should call the superclass
implementation (to raise <code>TypeError</code>).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.JSONEncoder', this);">Show source &equiv;</a></p>
  <div id="source-hjson.JSONEncoder" class="source">
    <pre><code>class JSONEncoder(object):
    """Extensible JSON <http://json.org> encoder for Python data structures.

    Supports the following objects and types by default:

    +-------------------+---------------+
    | Python            | JSON          |
    +===================+===============+
    | dict, namedtuple  | object        |
    +-------------------+---------------+
    | list, tuple       | array         |
    +-------------------+---------------+
    | str, unicode      | string        |
    +-------------------+---------------+
    | int, long, float  | number        |
    +-------------------+---------------+
    | True              | true          |
    +-------------------+---------------+
    | False             | false         |
    +-------------------+---------------+
    | None              | null          |
    +-------------------+---------------+

    To extend this to recognize other objects, subclass and implement a
    ``.default()`` method with another method that returns a serializable
    object for ``o`` if possible, otherwise it should call the superclass
    implementation (to raise ``TypeError``).

    """
    item_separator = ', '
    key_separator = ': '

    def __init__(self, skipkeys=False, ensure_ascii=True,
                 check_circular=True, sort_keys=False,
                 indent=None, separators=None, encoding='utf-8', default=None,
                 use_decimal=True, namedtuple_as_object=True,
                 tuple_as_array=True, bigint_as_string=False,
                 item_sort_key=None, for_json=False,
                 int_as_string_bitcount=None):
        """Constructor for JSONEncoder, with sensible defaults.

        If skipkeys is false, then it is a TypeError to attempt
        encoding of keys that are not str, int, long, float or None.  If
        skipkeys is True, such items are simply skipped.

        If ensure_ascii is true, the output is guaranteed to be str
        objects with all incoming unicode characters escaped.  If
        ensure_ascii is false, the output will be unicode object.

        If check_circular is true, then lists, dicts, and custom encoded
        objects will be checked for circular references during encoding to
        prevent an infinite recursion (which would cause an OverflowError).
        Otherwise, no such check takes place.

        If sort_keys is true, then the output of dictionaries will be
        sorted by key; this is useful for regression tests to ensure
        that JSON serializations can be compared on a day-to-day basis.

        If indent is a string, then JSON array elements and object members
        will be pretty-printed with a newline followed by that string repeated
        for each level of nesting. ``None`` (the default) selects the most compact
        representation without any newlines. For backwards compatibility with
        versions of hjson earlier than 2.1.0, an integer is also accepted
        and is converted to a string with that many spaces.

        If specified, separators should be an (item_separator, key_separator)
        tuple.  The default is (', ', ': ') if *indent* is ``None`` and
        (',', ': ') otherwise.  To get the most compact JSON representation,
        you should specify (',', ':') to eliminate whitespace.

        If specified, default is a function that gets called for objects
        that can't otherwise be serialized.  It should return a JSON encodable
        version of the object or raise a ``TypeError``.

        If encoding is not None, then all input strings will be
        transformed into unicode using that encoding prior to JSON-encoding.
        The default is UTF-8.

        If use_decimal is true (not the default), ``decimal.Decimal`` will
        be supported directly by the encoder. For the inverse, decode JSON
        with ``parse_float=decimal.Decimal``.

        If namedtuple_as_object is true (the default), objects with
        ``_asdict()`` methods will be encoded as JSON objects.

        If tuple_as_array is true (the default), tuple (and subclasses) will
        be encoded as JSON arrays.

        If bigint_as_string is true (not the default), ints 2**53 and higher
        or lower than -2**53 will be encoded as strings. This is to avoid the
        rounding that happens in Javascript otherwise.

        If int_as_string_bitcount is a positive number (n), then int of size
        greater than or equal to 2**n or lower than or equal to -2**n will be
        encoded as strings.

        If specified, item_sort_key is a callable used to sort the items in
        each dictionary. This is useful if you want to sort items other than
        in alphabetical order by key.

        If for_json is true (not the default), objects with a ``for_json()``
        method will use the return value of that method for encoding as JSON
        instead of the object.

        """

        self.skipkeys = skipkeys
        self.ensure_ascii = ensure_ascii
        self.check_circular = check_circular
        self.sort_keys = sort_keys
        self.use_decimal = use_decimal
        self.namedtuple_as_object = namedtuple_as_object
        self.tuple_as_array = tuple_as_array
        self.bigint_as_string = bigint_as_string
        self.item_sort_key = item_sort_key
        self.for_json = for_json
        self.int_as_string_bitcount = int_as_string_bitcount
        if indent is not None and not isinstance(indent, string_types):
            indent = indent * ' '
        self.indent = indent
        if separators is not None:
            self.item_separator, self.key_separator = separators
        elif indent is not None:
            self.item_separator = ','
        if default is not None:
            self.default = default
        self.encoding = encoding

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).

        For example, to support arbitrary iterators, you could
        implement default like this::

            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                return JSONEncoder.default(self, o)

        """
        raise TypeError(repr(o) + " is not JSON serializable")

    def encode(self, o):
        """Return a JSON string representation of a Python data structure.

        >>> from hjson import JSONEncoder
        >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
        '{"foo": ["bar", "baz"]}'

        """
        # This is for extremely simple cases and benchmarks.
        if isinstance(o, binary_type):
            _encoding = self.encoding
            if (_encoding is not None and not (_encoding == 'utf-8')):
                o = o.decode(_encoding)
        if isinstance(o, string_types):
            if self.ensure_ascii:
                return encode_basestring_ascii(o)
            else:
                return encode_basestring(o)
        # This doesn't pass the iterator directly to ''.join() because the
        # exceptions aren't as detailed.  The list call should be roughly
        # equivalent to the PySequence_Fast that ''.join() would do.
        chunks = self.iterencode(o, _one_shot=True)
        if not isinstance(chunks, (list, tuple)):
            chunks = list(chunks)
        if self.ensure_ascii:
            return ''.join(chunks)
        else:
            return u''.join(chunks)

    def iterencode(self, o, _one_shot=False):
        """Encode the given object and yield each string
        representation as available.

        For example::

            for chunk in JSONEncoder().iterencode(bigobject):
                mysocket.write(chunk)

        """
        if self.check_circular:
            markers = {}
        else:
            markers = None
        if self.ensure_ascii:
            _encoder = encode_basestring_ascii
        else:
            _encoder = encode_basestring
        if self.encoding != 'utf-8':
            def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
                if isinstance(o, binary_type):
                    o = o.decode(_encoding)
                return _orig_encoder(o)

        def floatstr(o, _repr=FLOAT_REPR, _inf=PosInf, _neginf=-PosInf):
            # Check for specials. Note that this type of test is processor
            # and/or platform-specific, so do tests which don't depend on
            # the internals.

            if o != o:
                text = 'null'
            elif o == _inf:
                text = 'null'
            elif o == _neginf:
                text = 'null'
            else:
                return _repr(o)

            return text

        key_memo = {}
        int_as_string_bitcount = (
            53 if self.bigint_as_string else self.int_as_string_bitcount)
        _iterencode = _make_iterencode(
            markers, self.default, _encoder, self.indent, floatstr,
            self.key_separator, self.item_separator, self.sort_keys,
            self.skipkeys, _one_shot, self.use_decimal,
            self.namedtuple_as_object, self.tuple_as_array,
            int_as_string_bitcount,
            self.item_sort_key, self.encoding, self.for_json,
            Decimal=Decimal)
        try:
            return _iterencode(o, 0)
        finally:
            key_memo.clear()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#hjson.JSONEncoder">JSONEncoder</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="hjson.JSONEncoder.item_separator" class="name">var <span class="ident">item_separator</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.key_separator" class="name">var <span class="ident">key_separator</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="hjson.JSONEncoder.bigint_as_string" class="name">var <span class="ident">bigint_as_string</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.check_circular" class="name">var <span class="ident">check_circular</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.encoding" class="name">var <span class="ident">encoding</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.ensure_ascii" class="name">var <span class="ident">ensure_ascii</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.for_json" class="name">var <span class="ident">for_json</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.indent" class="name">var <span class="ident">indent</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.int_as_string_bitcount" class="name">var <span class="ident">int_as_string_bitcount</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.item_sort_key" class="name">var <span class="ident">item_sort_key</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.namedtuple_as_object" class="name">var <span class="ident">namedtuple_as_object</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.skipkeys" class="name">var <span class="ident">skipkeys</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.sort_keys" class="name">var <span class="ident">sort_keys</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.tuple_as_array" class="name">var <span class="ident">tuple_as_array</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="hjson.JSONEncoder.use_decimal" class="name">var <span class="ident">use_decimal</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="hjson.JSONEncoder.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, skipkeys=False, ensure_ascii=True, check_circular=True, sort_keys=False, indent=None, separators=None, encoding=&#39;utf-8&#39;, default=None, use_decimal=True, namedtuple_as_object=True, tuple_as_array=True, bigint_as_string=False, item_sort_key=None, for_json=False, int_as_string_bitcount=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, long, float or None.  If
skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming unicode characters escaped.  If
ensure_ascii is false, the output will be unicode object.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an OverflowError).
Otherwise, no such check takes place.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a string, then JSON array elements and object members
will be pretty-printed with a newline followed by that string repeated
for each level of nesting. <code>None</code> (the default) selects the most compact
representation without any newlines. For backwards compatibility with
versions of hjson earlier than 2.1.0, an integer is also accepted
and is converted to a string with that many spaces.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.  The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.  To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.  It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p>
<p>If encoding is not None, then all input strings will be
transformed into unicode using that encoding prior to JSON-encoding.
The default is UTF-8.</p>
<p>If use_decimal is true (not the default), <code>decimal.Decimal</code> will
be supported directly by the encoder. For the inverse, decode JSON
with <code>parse_float=decimal.Decimal</code>.</p>
<p>If namedtuple_as_object is true (the default), objects with
<code>_asdict()</code> methods will be encoded as JSON objects.</p>
<p>If tuple_as_array is true (the default), tuple (and subclasses) will
be encoded as JSON arrays.</p>
<p>If bigint_as_string is true (not the default), ints 2<strong>53 and higher
or lower than -2</strong>53 will be encoded as strings. This is to avoid the
rounding that happens in Javascript otherwise.</p>
<p>If int_as_string_bitcount is a positive number (n), then int of size
greater than or equal to 2<strong>n or lower than or equal to -2</strong>n will be
encoded as strings.</p>
<p>If specified, item_sort_key is a callable used to sort the items in
each dictionary. This is useful if you want to sort items other than
in alphabetical order by key.</p>
<p>If for_json is true (not the default), objects with a <code>for_json()</code>
method will use the return value of that method for encoding as JSON
instead of the object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.JSONEncoder.__init__', this);">Show source &equiv;</a></p>
  <div id="source-hjson.JSONEncoder.__init__" class="source">
    <pre><code>def __init__(self, skipkeys=False, ensure_ascii=True,
             check_circular=True, sort_keys=False,
             indent=None, separators=None, encoding='utf-8', default=None,
             use_decimal=True, namedtuple_as_object=True,
             tuple_as_array=True, bigint_as_string=False,
             item_sort_key=None, for_json=False,
             int_as_string_bitcount=None):
    """Constructor for JSONEncoder, with sensible defaults.
    If skipkeys is false, then it is a TypeError to attempt
    encoding of keys that are not str, int, long, float or None.  If
    skipkeys is True, such items are simply skipped.
    If ensure_ascii is true, the output is guaranteed to be str
    objects with all incoming unicode characters escaped.  If
    ensure_ascii is false, the output will be unicode object.
    If check_circular is true, then lists, dicts, and custom encoded
    objects will be checked for circular references during encoding to
    prevent an infinite recursion (which would cause an OverflowError).
    Otherwise, no such check takes place.
    If sort_keys is true, then the output of dictionaries will be
    sorted by key; this is useful for regression tests to ensure
    that JSON serializations can be compared on a day-to-day basis.
    If indent is a string, then JSON array elements and object members
    will be pretty-printed with a newline followed by that string repeated
    for each level of nesting. ``None`` (the default) selects the most compact
    representation without any newlines. For backwards compatibility with
    versions of hjson earlier than 2.1.0, an integer is also accepted
    and is converted to a string with that many spaces.
    If specified, separators should be an (item_separator, key_separator)
    tuple.  The default is (', ', ': ') if *indent* is ``None`` and
    (',', ': ') otherwise.  To get the most compact JSON representation,
    you should specify (',', ':') to eliminate whitespace.
    If specified, default is a function that gets called for objects
    that can't otherwise be serialized.  It should return a JSON encodable
    version of the object or raise a ``TypeError``.
    If encoding is not None, then all input strings will be
    transformed into unicode using that encoding prior to JSON-encoding.
    The default is UTF-8.
    If use_decimal is true (not the default), ``decimal.Decimal`` will
    be supported directly by the encoder. For the inverse, decode JSON
    with ``parse_float=decimal.Decimal``.
    If namedtuple_as_object is true (the default), objects with
    ``_asdict()`` methods will be encoded as JSON objects.
    If tuple_as_array is true (the default), tuple (and subclasses) will
    be encoded as JSON arrays.
    If bigint_as_string is true (not the default), ints 2**53 and higher
    or lower than -2**53 will be encoded as strings. This is to avoid the
    rounding that happens in Javascript otherwise.
    If int_as_string_bitcount is a positive number (n), then int of size
    greater than or equal to 2**n or lower than or equal to -2**n will be
    encoded as strings.
    If specified, item_sort_key is a callable used to sort the items in
    each dictionary. This is useful if you want to sort items other than
    in alphabetical order by key.
    If for_json is true (not the default), objects with a ``for_json()``
    method will use the return value of that method for encoding as JSON
    instead of the object.
    """
    self.skipkeys = skipkeys
    self.ensure_ascii = ensure_ascii
    self.check_circular = check_circular
    self.sort_keys = sort_keys
    self.use_decimal = use_decimal
    self.namedtuple_as_object = namedtuple_as_object
    self.tuple_as_array = tuple_as_array
    self.bigint_as_string = bigint_as_string
    self.item_sort_key = item_sort_key
    self.for_json = for_json
    self.int_as_string_bitcount = int_as_string_bitcount
    if indent is not None and not isinstance(indent, string_types):
        indent = indent * ' '
    self.indent = indent
    if separators is not None:
        self.item_separator, self.key_separator = separators
    elif indent is not None:
        self.item_separator = ','
    if default is not None:
        self.default = default
    self.encoding = encoding
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.JSONEncoder.default">
    <p>def <span class="ident">default</span>(</p><p>self, o)</p>
    </div>
    

    
  
    <div class="desc"><p>Implement this method in a subclass such that it returns
a serializable object for <code>o</code>, or calls the base implementation
(to raise a <code>TypeError</code>).</p>
<p>For example, to support arbitrary iterators, you could
implement default like this::</p>
<pre><code>def default(self, o):
    try:
        iterable = iter(o)
    except TypeError:
        pass
    else:
        return list(iterable)
    return JSONEncoder.default(self, o)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.JSONEncoder.default', this);">Show source &equiv;</a></p>
  <div id="source-hjson.JSONEncoder.default" class="source">
    <pre><code>def default(self, o):
    """Implement this method in a subclass such that it returns
    a serializable object for ``o``, or calls the base implementation
    (to raise a ``TypeError``).
    For example, to support arbitrary iterators, you could
    implement default like this::
        def default(self, o):
            try:
                iterable = iter(o)
            except TypeError:
                pass
            else:
                return list(iterable)
            return JSONEncoder.default(self, o)
    """
    raise TypeError(repr(o) + " is not JSON serializable")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.JSONEncoder.encode">
    <p>def <span class="ident">encode</span>(</p><p>self, o)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a JSON string representation of a Python data structure.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from hjson import JSONEncoder
JSONEncoder().encode({"foo": ["bar", "baz"]})
'{"foo": ["bar", "baz"]}'</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.JSONEncoder.encode', this);">Show source &equiv;</a></p>
  <div id="source-hjson.JSONEncoder.encode" class="source">
    <pre><code>def encode(self, o):
    """Return a JSON string representation of a Python data structure.
    >>> from hjson import JSONEncoder
    >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
    '{"foo": ["bar", "baz"]}'
    """
    # This is for extremely simple cases and benchmarks.
    if isinstance(o, binary_type):
        _encoding = self.encoding
        if (_encoding is not None and not (_encoding == 'utf-8')):
            o = o.decode(_encoding)
    if isinstance(o, string_types):
        if self.ensure_ascii:
            return encode_basestring_ascii(o)
        else:
            return encode_basestring(o)
    # This doesn't pass the iterator directly to ''.join() because the
    # exceptions aren't as detailed.  The list call should be roughly
    # equivalent to the PySequence_Fast that ''.join() would do.
    chunks = self.iterencode(o, _one_shot=True)
    if not isinstance(chunks, (list, tuple)):
        chunks = list(chunks)
    if self.ensure_ascii:
        return ''.join(chunks)
    else:
        return u''.join(chunks)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.JSONEncoder.iterencode">
    <p>def <span class="ident">iterencode</span>(</p><p>self, o, _one_shot=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Encode the given object and yield each string
representation as available.</p>
<p>For example::</p>
<pre><code>for chunk in JSONEncoder().iterencode(bigobject):
    mysocket.write(chunk)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.JSONEncoder.iterencode', this);">Show source &equiv;</a></p>
  <div id="source-hjson.JSONEncoder.iterencode" class="source">
    <pre><code>def iterencode(self, o, _one_shot=False):
    """Encode the given object and yield each string
    representation as available.
    For example::
        for chunk in JSONEncoder().iterencode(bigobject):
            mysocket.write(chunk)
    """
    if self.check_circular:
        markers = {}
    else:
        markers = None
    if self.ensure_ascii:
        _encoder = encode_basestring_ascii
    else:
        _encoder = encode_basestring
    if self.encoding != 'utf-8':
        def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
            if isinstance(o, binary_type):
                o = o.decode(_encoding)
            return _orig_encoder(o)
    def floatstr(o, _repr=FLOAT_REPR, _inf=PosInf, _neginf=-PosInf):
        # Check for specials. Note that this type of test is processor
        # and/or platform-specific, so do tests which don't depend on
        # the internals.
        if o != o:
            text = 'null'
        elif o == _inf:
            text = 'null'
        elif o == _neginf:
            text = 'null'
        else:
            return _repr(o)
        return text
    key_memo = {}
    int_as_string_bitcount = (
        53 if self.bigint_as_string else self.int_as_string_bitcount)
    _iterencode = _make_iterencode(
        markers, self.default, _encoder, self.indent, floatstr,
        self.key_separator, self.item_separator, self.sort_keys,
        self.skipkeys, _one_shot, self.use_decimal,
        self.namedtuple_as_object, self.tuple_as_array,
        int_as_string_bitcount,
        self.item_sort_key, self.encoding, self.for_json,
        Decimal=Decimal)
    try:
        return _iterencode(o, 0)
    finally:
        key_memo.clear()
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="hjson.OrderedDict" class="name">class <span class="ident">OrderedDict</span></p>
      
  
    <div class="desc"><p>Dictionary that remembers insertion order</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict" class="source">
    <pre><code>class OrderedDict(dict):
    'Dictionary that remembers insertion order'
    # An inherited dict maps keys to values.
    # The inherited dict provides __getitem__, __len__, __contains__, and get.
    # The remaining methods are order-aware.
    # Big-O running times for all methods are the same as regular dictionaries.

    # The internal self.__map dict maps keys to links in a doubly linked list.
    # The circular doubly linked list starts and ends with a sentinel element.
    # The sentinel element never gets deleted (this simplifies the algorithm).
    # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

    def __init__(*args, **kwds):
        '''Initialize an ordered dictionary.  The signature is the same as
        regular dictionaries, but keyword arguments are not recommended because
        their insertion order is arbitrary.

        '''
        if not args:
            raise TypeError("descriptor '__init__' of 'OrderedDict' object "
                            "needs an argument")
        self = args[0]
        args = args[1:]
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        try:
            self.__root
        except AttributeError:
            self.__root = root = []                     # sentinel node
            root[:] = [root, root, None]
            self.__map = {}
        self.__update(*args, **kwds)

    def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
        'od.__setitem__(i, y) <==> od[i]=y'
        # Setting a new item creates a new link at the end of the linked list,
        # and the inherited dictionary is updated with the new key/value pair.
        if key not in self:
            root = self.__root
            last = root[0]
            last[1] = root[0] = self.__map[key] = [last, root, key]
        return dict_setitem(self, key, value)

    def __delitem__(self, key, dict_delitem=dict.__delitem__):
        'od.__delitem__(y) <==> del od[y]'
        # Deleting an existing item uses self.__map to find the link which gets
        # removed by updating the links in the predecessor and successor nodes.
        dict_delitem(self, key)
        link_prev, link_next, _ = self.__map.pop(key)
        link_prev[1] = link_next                        # update link_prev[NEXT]
        link_next[0] = link_prev                        # update link_next[PREV]

    def __iter__(self):
        'od.__iter__() <==> iter(od)'
        # Traverse the linked list in order.
        root = self.__root
        curr = root[1]                                  # start at the first node
        while curr is not root:
            yield curr[2]                               # yield the curr[KEY]
            curr = curr[1]                              # move to next node

    def __reversed__(self):
        'od.__reversed__() <==> reversed(od)'
        # Traverse the linked list in reverse order.
        root = self.__root
        curr = root[0]                                  # start at the last node
        while curr is not root:
            yield curr[2]                               # yield the curr[KEY]
            curr = curr[0]                              # move to previous node

    def clear(self):
        'od.clear() -> None.  Remove all items from od.'
        root = self.__root
        root[:] = [root, root, None]
        self.__map.clear()
        dict.clear(self)

    # -- the following methods do not depend on the internal structure --

    def keys(self):
        'od.keys() -> list of keys in od'
        return list(self)

    def values(self):
        'od.values() -> list of values in od'
        return [self[key] for key in self]

    def items(self):
        'od.items() -> list of (key, value) pairs in od'
        return [(key, self[key]) for key in self]

    def iterkeys(self):
        'od.iterkeys() -> an iterator over the keys in od'
        return iter(self)

    def itervalues(self):
        'od.itervalues -> an iterator over the values in od'
        for k in self:
            yield self[k]

    def iteritems(self):
        'od.iteritems -> an iterator over the (key, value) pairs in od'
        for k in self:
            yield (k, self[k])

    update = MutableMapping.update

    __update = update # let subclasses override update without breaking __init__

    __marker = object()

    def pop(self, key, default=__marker):
        '''od.pop(k[,d]) -> v, remove specified key and return the corresponding
        value.  If key is not found, d is returned if given, otherwise KeyError
        is raised.

        '''
        if key in self:
            result = self[key]
            del self[key]
            return result
        if default is self.__marker:
            raise KeyError(key)
        return default

    def setdefault(self, key, default=None):
        'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
        if key in self:
            return self[key]
        self[key] = default
        return default

    def popitem(self, last=True):
        '''od.popitem() -> (k, v), return and remove a (key, value) pair.
        Pairs are returned in LIFO order if last is true or FIFO order if false.

        '''
        if not self:
            raise KeyError('dictionary is empty')
        key = next(reversed(self) if last else iter(self))
        value = self.pop(key)
        return key, value

    def __repr__(self, _repr_running={}):
        'od.__repr__() <==> repr(od)'
        call_key = id(self), _get_ident()
        if call_key in _repr_running:
            return '...'
        _repr_running[call_key] = 1
        try:
            if not self:
                return '%s()' % (self.__class__.__name__,)
            return '%s(%r)' % (self.__class__.__name__, self.items())
        finally:
            del _repr_running[call_key]

    def __reduce__(self):
        'Return state information for pickling'
        items = [[k, self[k]] for k in self]
        inst_dict = vars(self).copy()
        for k in vars(OrderedDict()):
            inst_dict.pop(k, None)
        if inst_dict:
            return (self.__class__, (items,), inst_dict)
        return self.__class__, (items,)

    def copy(self):
        'od.copy() -> a shallow copy of od'
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S.
        If not specified, the value defaults to None.

        '''
        self = cls()
        for key in iterable:
            self[key] = value
        return self

    def __eq__(self, other):
        '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
        while comparison to a regular mapping is order-insensitive.

        '''
        if isinstance(other, OrderedDict):
            return dict.__eq__(self, other) and all(_imap(_eq, self, other))
        return dict.__eq__(self, other)

    def __ne__(self, other):
        'od.__ne__(y) <==> od!=y'
        return not self == other

    # -- the following methods support python 3.x style dictionary views --

    def viewkeys(self):
        "od.viewkeys() -> a set-like object providing a view on od's keys"
        return KeysView(self)

    def viewvalues(self):
        "od.viewvalues() -> an object providing a view on od's values"
        return ValuesView(self)

    def viewitems(self):
        "od.viewitems() -> a set-like object providing a view on od's items"
        return ItemsView(self)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#hjson.OrderedDict">OrderedDict</a></li>
          <li>__builtin__.dict</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>*args, **kwds)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize an ordered dictionary.  The signature is the same as
regular dictionaries, but keyword arguments are not recommended because
their insertion order is arbitrary.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.__init__', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.__init__" class="source">
    <pre><code>def __init__(*args, **kwds):
    '''Initialize an ordered dictionary.  The signature is the same as
    regular dictionaries, but keyword arguments are not recommended because
    their insertion order is arbitrary.
    '''
    if not args:
        raise TypeError("descriptor '__init__' of 'OrderedDict' object "
                        "needs an argument")
    self = args[0]
    args = args[1:]
    if len(args) > 1:
        raise TypeError('expected at most 1 arguments, got %d' % len(args))
    try:
        self.__root
    except AttributeError:
        self.__root = root = []                     # sentinel node
        root[:] = [root, root, None]
        self.__map = {}
    self.__update(*args, **kwds)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.clear">
    <p>def <span class="ident">clear</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>od.clear() -&gt; None.  Remove all items from od.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.clear', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.clear" class="source">
    <pre><code>def clear(self):
    'od.clear() -> None.  Remove all items from od.'
    root = self.__root
    root[:] = [root, root, None]
    self.__map.clear()
    dict.clear(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.copy">
    <p>def <span class="ident">copy</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>od.copy() -&gt; a shallow copy of od</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.copy', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.copy" class="source">
    <pre><code>def copy(self):
    'od.copy() -> a shallow copy of od'
    return self.__class__(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.fromkeys">
    <p>def <span class="ident">fromkeys</span>(</p><p>cls, iterable, value=None)</p>
    </div>
    

    
  
    <div class="desc"><p>OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.
If not specified, the value defaults to None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.fromkeys', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.fromkeys" class="source">
    <pre><code>@classmethod
def fromkeys(cls, iterable, value=None):
    '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S.
    If not specified, the value defaults to None.
    '''
    self = cls()
    for key in iterable:
        self[key] = value
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.items">
    <p>def <span class="ident">items</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>od.items() -&gt; list of (key, value) pairs in od</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.items', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.items" class="source">
    <pre><code>def items(self):
    'od.items() -> list of (key, value) pairs in od'
    return [(key, self[key]) for key in self]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.iteritems">
    <p>def <span class="ident">iteritems</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>od.iteritems -&gt; an iterator over the (key, value) pairs in od</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.iteritems', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.iteritems" class="source">
    <pre><code>def iteritems(self):
    'od.iteritems -> an iterator over the (key, value) pairs in od'
    for k in self:
        yield (k, self[k])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.iterkeys">
    <p>def <span class="ident">iterkeys</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>od.iterkeys() -&gt; an iterator over the keys in od</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.iterkeys', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.iterkeys" class="source">
    <pre><code>def iterkeys(self):
    'od.iterkeys() -> an iterator over the keys in od'
    return iter(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.itervalues">
    <p>def <span class="ident">itervalues</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>od.itervalues -&gt; an iterator over the values in od</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.itervalues', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.itervalues" class="source">
    <pre><code>def itervalues(self):
    'od.itervalues -> an iterator over the values in od'
    for k in self:
        yield self[k]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.keys">
    <p>def <span class="ident">keys</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>od.keys() -&gt; list of keys in od</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.keys', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.keys" class="source">
    <pre><code>def keys(self):
    'od.keys() -> list of keys in od'
    return list(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.pop">
    <p>def <span class="ident">pop</span>(</p><p>self, key, default=&lt;object object at 0x1081ca0a0&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding
value.  If key is not found, d is returned if given, otherwise KeyError
is raised.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.pop', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.pop" class="source">
    <pre><code>def pop(self, key, default=__marker):
    '''od.pop(k[,d]) -> v, remove specified key and return the corresponding
    value.  If key is not found, d is returned if given, otherwise KeyError
    is raised.
    '''
    if key in self:
        result = self[key]
        del self[key]
        return result
    if default is self.__marker:
        raise KeyError(key)
    return default
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.popitem">
    <p>def <span class="ident">popitem</span>(</p><p>self, last=True)</p>
    </div>
    

    
  
    <div class="desc"><p>od.popitem() -&gt; (k, v), return and remove a (key, value) pair.
Pairs are returned in LIFO order if last is true or FIFO order if false.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.popitem', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.popitem" class="source">
    <pre><code>def popitem(self, last=True):
    '''od.popitem() -> (k, v), return and remove a (key, value) pair.
    Pairs are returned in LIFO order if last is true or FIFO order if false.
    '''
    if not self:
        raise KeyError('dictionary is empty')
    key = next(reversed(self) if last else iter(self))
    value = self.pop(key)
    return key, value
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.setdefault">
    <p>def <span class="ident">setdefault</span>(</p><p>self, key, default=None)</p>
    </div>
    

    
  
    <div class="desc"><p>od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.setdefault', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.setdefault" class="source">
    <pre><code>def setdefault(self, key, default=None):
    'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
    if key in self:
        return self[key]
    self[key] = default
    return default
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.update">
    <p>def <span class="ident">update</span>(</p><p>*args, **kwds)</p>
    </div>
    

    
  
    <div class="desc"><p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.update', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.update" class="source">
    <pre><code>def update(*args, **kwds):
    ''' D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
        If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
        If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
        In either case, this is followed by: for k, v in F.items(): D[k] = v
    '''
    if not args:
        raise TypeError("descriptor 'update' of 'MutableMapping' object "
                        "needs an argument")
    self = args[0]
    args = args[1:]
    if len(args) > 1:
        raise TypeError('update expected at most 1 arguments, got %d' %
                        len(args))
    if args:
        other = args[0]
        if isinstance(other, Mapping):
            for key in other:
                self[key] = other[key]
        elif hasattr(other, "keys"):
            for key in other.keys():
                self[key] = other[key]
        else:
            for key, value in other:
                self[key] = value
    for key, value in kwds.items():
        self[key] = value
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.values">
    <p>def <span class="ident">values</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>od.values() -&gt; list of values in od</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.values', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.values" class="source">
    <pre><code>def values(self):
    'od.values() -> list of values in od'
    return [self[key] for key in self]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.viewitems">
    <p>def <span class="ident">viewitems</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>od.viewitems() -&gt; a set-like object providing a view on od's items</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.viewitems', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.viewitems" class="source">
    <pre><code>def viewitems(self):
    "od.viewitems() -> a set-like object providing a view on od's items"
    return ItemsView(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.viewkeys">
    <p>def <span class="ident">viewkeys</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>od.viewkeys() -&gt; a set-like object providing a view on od's keys</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.viewkeys', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.viewkeys" class="source">
    <pre><code>def viewkeys(self):
    "od.viewkeys() -> a set-like object providing a view on od's keys"
    return KeysView(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="hjson.OrderedDict.viewvalues">
    <p>def <span class="ident">viewvalues</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>od.viewvalues() -&gt; an object providing a view on od's values</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-hjson.OrderedDict.viewvalues', this);">Show source &equiv;</a></p>
  <div id="source-hjson.OrderedDict.viewvalues" class="source">
    <pre><code>def viewvalues(self):
    "od.viewvalues() -> an object providing a view on od's values"
    return ValuesView(self)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
